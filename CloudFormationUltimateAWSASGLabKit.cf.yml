---
AWSTemplateFormatVersion: '2010-09-09'
Description: >
  AWSASGLabKitVersion: 1.2:
  More Information https://gitlab.com/DarwinJS/ultimate-aws-asg-lab-kit/-/blob/master/README.md
Parameters:
  1AAAReadmeBlogPost:
    Description: Read the following post to learn why this template is helpful - Darwin.
    Type: String
    Default: https://gitlab.com/DarwinJS/ultimate-aws-asg-lab-kit/-/blob/master/README.md
  1OSPeggedAMIID:
    Description: >
      99% of the time you will want to leave this as "latest".  Override here if you have a dependency on a specific AMI or have prepared a custom one.
      Can be Windows or Linux, but the value choosen for 1OSInstanceOSPlatform must match the OS platform contained in the AMI.
      For testing pick an older one that will need a kernel patch or other reboot required patch for sure.
      For Linux - due to optimization and AWS ECR Creds Helper, Amazon Linux 2 is assumed, but other Redhat parentage distros may work (yum packager).
      CentOS7 (use M4): ami-4bf3d731.
    Type: String
    Default: AlwaysUseLatest
  1OSInstanceOSPlatform:
    Description: >
      Enter "Linux" or "Windows".  AMI specified in 9AWSRetrieveLatestAWSOSAmiIdFromSSM or 1OSPeggedAMIID must contain this platform choice.
    Type: String
    Default: Linux
    AllowedValues: 
      - Linux
      - Windows
  1OSPatchRunDate:
    Description: >
      Enter the deploy or update date - changing this is required to force a rolling replacement for patching.
      It has a secondary purpose as a convenient way to document the patch date as an environment variable and an EC2 tag.  
      It is just a string that you could set to any value and has no role in selecting patches or anything else - but it 
      does need to change from it's previous setting in order for the update to be forced.
    Type: String
    Default: 2019-06-04
  1OSPatchScope:
    Description: What types of patches to apply
    Type: String
    Default: All
    AllowedValues: 
      - All
      - SecurityOnly
      - NoPatching-OnlyForDebugging   
      #For "NoPatching-OnlyForDebugging" - No patching will be done - this setting is for debugging only (patch dates will still be set)   
  3INSTConfigurationScript:
    Description: >
      Allows additional script commands during startup. This is parameterized for testing new versions and to enable one
      CloudFormation template codebase to be used for many different Autoscaling groups. It also allows you to use this template
      without customizing it so that you can take future updates without headache. Windows 2012 and earlier also have a userdata size
      limit of 16Kb - this method gets around that.
      1) "Embedded" uses the code right in this template and does not use external files at all.
      2) Enter a URL starting with s3://, http:// or https:// to dynamically source one during instance provisioning.
      s3 allows easy private file storage.  http/s enables usage of git raw urls (whether public or private).
      3) Enter a file pathname on the local instance. The file must be present in the location by the time Userdata processes
      (e.g. via a custom AMI)
      The instance must have a network route and permission to any remote locations.
      The code you write must be idempotent so that it does the correct thing when run again after a patching reboot.
      There is an example at: https://gitlab.com/DarwinJS/ultimate-aws-asg-lab-kit/-/raw/master/CustomInstanceConfigurationScriptSample.sh_and_ps1
    Type: String
    Default: Embedded
  3INSTInstallCodeDeploy:
    Description: Installs CodeDeploy so it can be used for initial deployments and updates.
    Type: String
    Default: false
    AllowedValues: 
      - true
      - false 
  4ASGDesiredCapacity:
    Description: >
      This template uses ASGs for HA - even if you choose not to autoscale.
      Desired capacity of 1 enables HOT/WARM through ASG Respawn.  Use this for applications where there CANNOT be more than one instance of this server/service role.
      Desired capacity of 2 enables HOT/HOT since loss of a node does not require respawn for recovery, but the application must support more than one instance of this server/service role.
      For testing, a desired capacity of 4 is a good number for testing rolling updates.  
      For testing all other functionality 1 is sufficient to observe how the userdata code processes to accomplish the yum update and reboot before the lifecycle hook.
    Type: Number
    Default: 4
  4ASGUpdateType:
    Description: (Only Applies To Updates) Whether ASG Update Should Do a Rolling Update or an ASG Replacement.
    Type: String
    Default: RollingThroughInstances
    AllowedValues: 
      - ReplaceEntireASG
      - RollingThroughInstances
  5ASGAutoScalingEnabled:
    Description: >
      Setting to false still allows for High Availability - either HOT/Warm HA with 1 instance or HOT/HOT HA for 2 or more instances. 
      AWS resources for autoscaling are not created if this is false. The 'step scaling' policy is used.
    Type: String
    Default: true
    AllowedValues: 
      - true
      - false
  5ASGAutoScalingMaxSize:
    Description: >
      Maximum number of instances the ASG can contain.
    Type: Number
    Default: 10
  5ASGSelfMonitorTerminationInterval:  
    Description: >
      How often in minutes should the instance check if it is being asked to terminate so it can run a clean up script.
      Terminations initiated by spot occur two minutes after notification, so this value should less than that for spot implementations.
      AWS and instance resources for monitoring termination are not created if this value is not provided.
      It is best practice to delete this if a termination hook truely is not needed for cleanup.
    Type: String
    Default: 1
    AllowedValues:
     - 1
     - 2
     - 3
     - 4
     - 5
     - Disabled
  5ASGAutoScalingSetScaleOutCPUThreshold:
    Description: >
      What ASG-wide CPU threshold triggers scaling up via step-scaling? Requires 5ASGAutoScalingEnabled=true.
    Type: Number
    Default: 70  
  5ASGAutoScalingSetScaleOutCPUThresholdSeconds:
    Description: >
      How many seconds does the threshold have to be in alarm to trigger scale up via step-scaling? Requires 5ASGAutoScalingEnabled=true.
    Type: Number
    Default: 60     
  5ASGAutoScalingSetScaleInCPUThreshold:
    Description: >
      What ASG-wide CPU threshold triggers scaling down via step-scaling? Requires 5ASGAutoScalingEnabled=true.
    Type: Number
    Default: 20  
  5ASGAutoScalingSetScaleInCPUThresholdSeconds:
    Description: >
      How many seconds does the threshold have to be in alarm to trigger scale down? Requires 5ASGAutoScalingEnabled=true.
    Type: Number
    Default: 60    
  5SPOTInstanceType1:
    Description: >
      ATTENTION: DISABLING SPOT *instance usage* is achieved by setting 5SPOTOnDemandPercentageAboveBaseCapacity to 0 (zero).
      It still results in a spot setup, but none of the instances will be spot instances.
      At least one instancetype is required, use at least 2 to demonstrate spot. You do not have to keep your instance
      sizes small because the lowest price will always be choosen and is likely cheaper than small on demand instances.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
    Default: "m4.large"
    AllowedPattern: ^[A-Za-z0-9.]+$
    ConstraintDescription: At least two instancetypes are required, use at least 2 to demonstrate spot.
  5SPOTInstanceType2:
    Description: >
      At least one instancetype is required, use at least 2 to demonstrate spot. You do not have to keep your instance
      sizes small because the lowest price will always be choosen and is likely cheaper than small on demand instances.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
  5SPOTInstanceType3:
    Description: >
      At least one instancetype is required, use at least 2 to demonstrate spot. You do not have to keep your instance
      sizes small because the lowest price will always be choosen and is likely cheaper than small on demand instances.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
  5SPOTInstanceType4:
    Description: >
      At least one instancetype is required, use at least 2 to demonstrate spot. You do not have to keep your instance
      sizes small because the lowest price will always be choosen and is likely cheaper than small on demand instances.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
  5SPOTSpotAllocationStrategy:
    Description: >
      Determines which allocation strategy to use. 'capacity-optimized' helps reduce spot terminations.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
    Default: lowest-price
    AllowedValues: 
      - lowest-price
      - capacity-optimized      
  5SPOTOnDemandBaseCapacity:
    Description: >
      Sets a minimum number of always on on-demand (non-spot) base capacity.  The number of instances here will benefit from InstanceType 
      exhaustion, but not spot pricing. Set to 0 for a 100% spot cluster.
    Type: Number
    Default: 0
  5SPOTOnDemandPercentageAboveBaseCapacity: 
    Description: >
      ATTENTION: DISABLING SPOT *instance usage* is achieved by setting this value to 0 (zero). It still results in a spot setup, but none of
      the instances will be spot instances.
      What percent of the cluster should be Spot (with the remainder being on demand).  Percentage only applied to instances started after
      count in 5SPOTOnDemandBaseCapacity.
      Set to 100 for a 100% spot cluster.
    Type: Number
    Default: 100
  8DBGCPULoadPercentInitialValue:
    Description: >
      WARNING: Everything is 1 minute granularity - so don't set this to cause scaling and forget it unless you want a massive AWS bill ;)
      Test your scaling parameters with synthetic cpu loading.  Enabled by entering a numeric value between 20-95.
      This will create an SSM parameter named {AWS::Stackname}-SyntheticCPULoad with the initial value entered here.
      The userdata script will then run a CPU stressing utility in a loop, checking the parameter every minute for
      updated values.  The value updates the CPU consumption in all ASG members so you can observe whether your scaling
      policy works.  Set to a non-numeric value to terminate the Synthetic Loading (cannot be reenabled without rebuilding stack).
      AWS Resources are only created to support this functionality if a value is provided during stack deployment.
      The utility for Windows has a challenge generating loads above 90 percent, if you have a better cli utility, I'm all ears.
      For parameters above that range, setup your steps below 90 and test them and then once verified, update the numbers to the
      higher values.
    Type: String
  8DBGTroubleShootingMode:
    Description: Enables troubleshooting - enables SSM and configures Instance Profile IAM so SSM Session Manager can logon.
    Type: String
    Default: false
    AllowedValues: 
      - true
      - false    
  8DBGSetupPseudoWebApp:
    Description: Puts up a web server with a simple landing page to map an ELB to it.  Warning, adds an ingress for port 80 to the VPC default security group.
    Type: String
    Default: false
    AllowedValues: 
      - true
      - false    
  9AWSSpecifiedIAMRoleNAME:
    Description: >
      Uses the specified IAM Role as the Instance Profile rather than building one. Must be the Role NAME (NOT THE ARN) which 
      allows abstracted reuse of the same name across multiple AWS accounts. 'CreateOneForMe' causes this template to create a role for you.
      IMPORTANT: For scaling and lifecycle hooks to work, a prebuilt role must contain at least the permissions specified in this template in
      the resource sections: ASGRebootRole, ASGSelfAccessPolicy and EC2SelfAccessPolicy.
    Type: String
    Default: CreateOneForMe
  9AWSRetrieveLatestAWSOSAmiIdFromSSM:
    Description: >
      Get LATEST AMI Build by AWS as of Template run. Set to SSM parameter path. Only used if 1OSPeggedAMIID is set to 'latest'. 
      PARAMETER STORE PATHS HAVE MANY MORE OPTIONS FOR WINDOWS AND QUITE A FEW FOR AMAZON LINUX
      COMMAND TO FIND WINDOWS OPTIONS (You are NOT restricted to ones that have docker preinstalled): aws ssm get-parameters-by-path 
      --path '/aws/service/ami-windows-latest' --region us-east-1 | grep 'Server.*English.*Containers' 
      COMMON WINDOWS OPTIONS: /aws/service/ami-windows-latest/Windows_Server-2012-R2_RTM-English-64Bit-Base,
      /aws/service/ami-windows-latest/Windows_Server-2012-R2_RTM-English-64Bit-Core,/aws/service/ami-windows-latest/Windows_Server-2016-English-Core-ContainersLatest,
      /aws/service/ami-windows-latest/Windows_Server-2016-English-Full-ContainersLatest,/aws/service/ami-windows-latest/Windows_Server-2019-English-Core-ContainersLatest,
      /aws/service/ami-windows-latest/Windows_Server-2019-English-Full-ContainersLatest,/aws/service/ami-windows-latest/Windows_Server-1903-English-Core-ContainersLatest,
      /aws/service/ami-windows-latest/Windows_Server-1809-English-Core-ContainersLatest
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2'
  ELBName:
    Description: ELBName (Optional) - overrides same name in parent stack exports if both are provided
    Type: String
  ParentStackName:
    Description: Parent stack name (Optional) - passes resources including ELBName
    Type: String
Conditions: 
  CreateDebugResources: !Equals [ !Ref 8DBGTroubleShootingMode, "true" ]
  ReplaceEntireASG: !Equals [ !Ref 4ASGUpdateType, "ReplaceEntireASG" ]
  8DBGSetupPseudoWebApp: !Equals [ !Ref 8DBGSetupPseudoWebApp, "true" ]
  ParentStackNameWasPassed: !Not [ !Equals [ !Ref ParentStackName, "" ]]
  ELBNameWasPassed: !Not [ !Equals [ !Ref ELBName, "" ]]
  InstancePlatformLinux: !Equals [ !Ref 1OSInstanceOSPlatform, "Linux" ]
  UseLatestAMI: !Equals [ !Ref 1OSPeggedAMIID, "AlwaysUseLatest"]
  BuildInstanceRoleToUse: !Equals [ !Ref 9AWSSpecifiedIAMRoleNAME, "CreateOneForMe" ]
  ConfigureAutoscaling: !Equals [ !Ref 5ASGAutoScalingEnabled, "true" ]
  SetupSythenticCPULoad: !Not [ !Equals [ !Ref 8DBGCPULoadPercentInitialValue, "" ]]
  Provided5SPOTInstanceType1: !Not [ !Equals [ !Ref 5SPOTInstanceType1, "" ]]
  Provided5SPOTInstanceType2: !Not [ !Equals [ !Ref 5SPOTInstanceType2, "" ]]
  Provided5SPOTInstanceType3: !Not [ !Equals [ !Ref 5SPOTInstanceType3, "" ]]
  Provided5SPOTInstanceType4: !Not [ !Equals [ !Ref 5SPOTInstanceType4, "" ]]
  EnableSelfTerminationMonitoring: !Not [ !Equals [ !Ref 5ASGSelfMonitorTerminationInterval, "Disabled" ]]
Resources:
  ASGRebootRole:
    Type: AWS::IAM::Role
    Condition: BuildInstanceRoleToUse
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Action: sts:AssumeRole
          Principal:
            Service:
              - ec2.amazonaws.com
      ManagedPolicyArns:
        !If
          - CreateDebugResources
          - 
            - arn:aws:iam::aws:policy/service-role/AmazonSSMMaintenanceWindowRole
            - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
            - arn:aws:iam::aws:policy/service-role/AmazonEC2RoleforSSM       
          - !Ref "AWS::NoValue"

  #IAM Policies for Instance Profile:
  ASGInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Condition: BuildInstanceRoleToUse
    Properties:
      Path: /
      Roles: [ !Ref ASGRebootRole ]

  ASGSelfAccessPolicy:
    Type: AWS::IAM::Policy
    Condition: BuildInstanceRoleToUse
    Properties:
      PolicyName: ASGSelfAccessPolicy
      Roles: [ !Ref ASGRebootRole ]
      PolicyDocument:
        Version: 2012-10-17
        Statement:
        - Sid: ASGSelfAccessPolicy
          Resource: "*"
          Effect: Allow
          Action:
            - iam:ListAccountAliases
            - autoscaling:DescribeAutoScalingInstances
            - autoscaling:DescribeAutoScalingGroups
            - autoscaling:DescribeLifecycle*                   
        - Sid: ASGLifeCycleAccessPolicy
          Resource: !Sub 'arn:${AWS::Partition}:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/${AWS::StackName}*'
          Effect: Allow
          Action:
            - autoscaling:CompleteLifecycleAction
            - autoscaling:RecordLifecycleActionHeartbeat
          #To use a tag condition, update Resource to '*' and uncomment this segement
          #Condition:
          #  StringEquals:
          #    autoscaling :ResourceTag/Name: !Ref AWS::StackName

  EC2SelfAccessPolicy:
    Type: AWS::IAM::Policy
    Condition: BuildInstanceRoleToUse
    Properties:
      PolicyName: EC2SelfAccessPolicy
      Roles: [ !Ref ASGRebootRole ]
      PolicyDocument:
        Version: 2012-10-17
        Statement:
        - Sid: EC2SelfAccessPolicy
          Resource: "*"
          Effect: Allow
          Action: 
            - ec2:DescribeInstances
            - ec2:DescribeTags
  
  #Give access to CPU Percent for ASG Scaling Testing
  SSMParameterStorePolicy:
    Type: AWS::IAM::Policy
    Condition: SetupSythenticCPULoad
    Properties:
      PolicyName: SSMParameterForCPUPercent
      Roles: [ !Ref ASGRebootRole ]
      PolicyDocument:
        Version: 2012-10-17
        Statement:
        - Sid: SSMParameterStorePolicy
          Resource: !Sub "arn:aws:autoscaling:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}-SyntheticCPULoad"
          Effect: Allow
          Action: 
            - ssm:GetParameters

  SSMSyntheticCPULoad:
    Type: AWS::SSM::Parameter
    Condition: SetupSythenticCPULoad    
    Properties:
      Name: !Sub "${AWS::StackName}-SyntheticCPULoad"
      Type: String 
      Value: !Ref 8DBGCPULoadPercentInitialValue
      Description: Named as stackname-SyntheticCPULoad, contains CPU Load Percent Value.

  WebPlusDefaultSecurityGroupSelfIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Condition: 8DBGSetupPseudoWebApp
    Properties:
      GroupName: default
      IpProtocol: tcp
      FromPort: 80
      ToPort: 80
      CidrIp: 0.0.0.0/0

  InstanceASG:
    Type: AWS::AutoScaling::AutoScalingGroup
    CreationPolicy:
      AutoScalingCreationPolicy:
        MinSuccessfulInstancesPercent: 75
      ResourceSignal:     
        !If
          - InstancePlatformLinux
          - 
            Timeout: PT15M
            Count: !Ref 4ASGDesiredCapacity
          - 
            Timeout: PT1H
            Count: !Ref 4ASGDesiredCapacity
    # Decide which UpdatePolicy to uncomment to see this template work with either one.
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MaxBatchSize: 2
        MinInstancesInService: 1
        MinSuccessfulInstancesPercent: 75
        WaitOnResourceSignals: true
        PauseTime: PT0M30S
        SuspendProcesses:
          - HealthCheck
          - ReplaceUnhealthy
          - AZRebalance
          - AlarmNotification
          - ScheduledActions
      AutoScalingReplacingUpdate:
        # WillReplace=True will make ReplacingUpdate take precedent over RollingUpdate
        !If
          - ReplaceEntireASG
          - WillReplace: 'true'
          - WillReplace: 'false'
    Properties:
      HealthCheckGracePeriod: 3
      AvailabilityZones:
        Fn::GetAZs:
          Ref: AWS::Region
      MinSize: '1'
      MaxSize: !Ref 5ASGAutoScalingMaxSize
      DesiredCapacity: !Ref 4ASGDesiredCapacity
      #Demonstrates an 1) **Optional dependency** on an ELB which can be sourced from either
      # 2) **A parent stack**, or 3) **overridden by a parameter** in this stack
      LoadBalancerNames:
        !If
         - ELBNameWasPassed
         - - !Ref ELBName 
         - !If
             - ParentStackNameWasPassed
             - - Fn::ImportValue:
                   !Sub "${ParentStackName}-ELBName" 
             - !Ref AWS::NoValue
      MixedInstancesPolicy:
        LaunchTemplate:
          LaunchTemplateSpecification:
            LaunchTemplateId:
              Ref: ASGLaunchTemplate
            Version: !GetAtt ASGLaunchTemplate.LatestVersionNumber 
          Overrides: 
            - !If 
              - Provided5SPOTInstanceType1
              - InstanceType: !Ref 5SPOTInstanceType1
              - !Ref "AWS::NoValue"
            - !If 
              - Provided5SPOTInstanceType2
              - InstanceType: !Ref 5SPOTInstanceType2
              - !Ref "AWS::NoValue"
            - !If 
              - Provided5SPOTInstanceType3
              - InstanceType: !Ref 5SPOTInstanceType3
              - !Ref "AWS::NoValue"
            - !If 
              - Provided5SPOTInstanceType4
              - InstanceType: !Ref 5SPOTInstanceType4
              - !Ref "AWS::NoValue"
        InstancesDistribution:
          SpotAllocationStrategy: !Ref 5SPOTSpotAllocationStrategy
          OnDemandAllocationStrategy: prioritized
          OnDemandBaseCapacity: !Ref 5SPOTOnDemandBaseCapacity
          OnDemandPercentageAboveBaseCapacity: !Ref 5SPOTOnDemandPercentageAboveBaseCapacity
      LifecycleHookSpecificationList:
      - LifecycleTransition: 'autoscaling:EC2_INSTANCE_LAUNCHING'
        LifecycleHookName: instance-patching-reboot
        HeartbeatTimeout: 3600
      - !If 
        - EnableSelfTerminationMonitoring
        - 
          LifecycleTransition: 'autoscaling:EC2_INSTANCE_TERMINATING'
          LifecycleHookName: instance-terminating
          HeartbeatTimeout: 3600
        - !Ref "AWS::NoValue"        

      Tags:
      - Key: Name
        Value: !Ref AWS::StackName
        PropagateAtLaunch: 'True'
      - Key: LAST_CF_PATCH_RUN
        Value: !Ref 1OSPatchRunDate
        PropagateAtLaunch: 'True'
  
  #Scaling policy and alarms are only created if autoscaling parameter is true
  ScaleDownPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Condition: ConfigureAutoscaling
    DependsOn: InstanceASG
    Properties:
      AutoScalingGroupName:
        Ref: InstanceASG
      #Replace the below section if a different type of scaling policy is desired
      PolicyType: StepScaling
      AdjustmentType: 'ChangeInCapacity'
      StepAdjustments:
        - MetricIntervalUpperBound: 0
          ScalingAdjustment: -1
      MetricAggregationType: 'Average'
      EstimatedInstanceWarmup: !If [InstancePlatformLinux,60,600]

  ScaleUpPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Condition: ConfigureAutoscaling    
    DependsOn: InstanceASG
    Properties:
      AutoScalingGroupName:
        Ref: InstanceASG
      PolicyType: StepScaling
      AdjustmentType: 'ChangeInCapacity'
      StepAdjustments:
        - MetricIntervalLowerBound: 0
          MetricIntervalUpperBound: 15
          ScalingAdjustment: 1
        - MetricIntervalLowerBound: 15
          MetricIntervalUpperBound: 25
          ScalingAdjustment: 2
        - MetricIntervalLowerBound: 25
          ScalingAdjustment: 3
      MetricAggregationType: 'Average'
      EstimatedInstanceWarmup: !If [InstancePlatformLinux,60,600]

  LowCpuUsageAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: ConfigureAutoscaling     
    DependsOn: InstanceASG
    Properties:
      AlarmDescription: "Low CPU alarm for: "
      MetricName: CPUUtilization
      Unit: Percent
      Namespace: AWS/EC2
      Dimensions:
        - Name: AutoScalingGroupName
          Value:
            Ref: InstanceASG
      Statistic: Average
      Period: !Ref 5ASGAutoScalingSetScaleInCPUThresholdSeconds
      EvaluationPeriods: 1
      Threshold: !Ref 5ASGAutoScalingSetScaleInCPUThreshold
      ComparisonOperator: LessThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleDownPolicy

  HighCpuUsageAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: ConfigureAutoscaling     
    DependsOn: InstanceASG
    Properties:
      AlarmDescription: "High CPU alarm for: "
      MetricName: CPUUtilization
      Unit: Percent      
      Namespace: AWS/EC2
      Dimensions:
        - Name: AutoScalingGroupName
          Value:
            Ref: InstanceASG
      Statistic: Average
      Period: !Ref 5ASGAutoScalingSetScaleOutCPUThresholdSeconds
      EvaluationPeriods: 1
      Threshold: !Ref 5ASGAutoScalingSetScaleOutCPUThreshold
      ComparisonOperator: GreaterThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleUpPolicy

  ASGLaunchTemplate:
    Type: "AWS::EC2::LaunchTemplate"
    Properties:
      LaunchTemplateData:
        ImageId:
          !If
            - UseLatestAMI
            - 
                Ref: 9AWSRetrieveLatestAWSOSAmiIdFromSSM
            - 
                Ref: 1OSPeggedAMIID
        #InstanceType is overridden by spot parameters
        InstanceType: t2.micro
        IamInstanceProfile:
          !If
            - BuildInstanceRoleToUse
            -   Arn: !GetAtt ASGInstanceProfile.Arn
            -   Arn: !Sub "arn:aws:iam::${AWS::AccountId}:instance-profile/${9AWSSpecifiedIAMRoleNAME}"
        BlockDeviceMappings:
        - DeviceName: "/dev/xvda"
          Ebs:
            VolumeType: 'gp2'
            VolumeSize: 30
        UserData:      
          !If
            - InstancePlatformLinux
            - 
              # **************
              # Linux UserData
              Fn::Base64: !Sub | 
                #!/bin/bash
                set -xv
                AWSASGLabKitVersion="1.2"
                function logit() {
                  LOGSTRING="$(date +"%_b %e %H:%M:%S") $(hostname) USERDATA_SCRIPT: $1"
                  echo "$LOGSTRING"
                  #For CloudFormation, if you already collect /var/log/cloud-init-output.log or /var/log/messsages (non amazon linux), then you could mute the next logging line
                  echo "$LOGSTRING" >> /var/log/messages
                }                     
                logit "Building Linux Instance... with AWS ASG Lab Kit Version: $AWSASGLabKitVersion"
                logit "Learn more at: $1AAAReadmeBlogPost"
                logit "Logs for this are found in /var/log/cloud-init-output.log or /var/log/messsages (non amazon linux)"
                logit "Rendered script found in /var/lib/cloud/instance/scripts/part-001"          
                if [[ "${8DBGTroubleShootingMode}" == "true" ]]; then
                  if ! ps -ef | grep -q '[a]mazon-ssm-agent'; then
                    logit "8DBGTroubleShootingMode is true - and SSM is not installed, Installing SSM for Session Manager Access..."
                    sudo yum install -y https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_amd64/amazon-ssm-agent.rpm
                    sudo start amazon-ssm-agent
                  fi
                fi
                if [[ -z "$(command -v aws)" ]] ; then
                  logit "AWS CLI is not present, installing it to control asg lifecycle hook completion..."
                  if [[ -z "$(command -v pip)" ]] ; then
                    logit "PIP is not present, installing for aws cli install"
                    curl -O https://bootstrap.pypa.io/get-pip.py
                    python get-pip.py
                  fi
                  pip install awscli --upgrade
                fi     
                if [[ ! -f /opt/aws/bin/cfn-signal ]] ; then
                  logit "cfn-bootstrap is not present, installing it to control cloud formation completion..."
                  yum install -y epel-release
                  yum install -y https://s3.amazonaws.com/cloudformation-examples/aws-cfn-bootstrap-latest.amzn1.noarch.rpm
                  sudo ln -s /usr/local/lib/python2.7/site-packages/cfnbootstrap /usr/lib/python2.7/site-packages/cfnbootstrap
                fi                                        
                INSTANCEOSPLATFORM=${1OSInstanceOSPlatform}
                LAST_CF_PATCH_RUN="${1OSPatchRunDate}" #Forces change for patching rolling replacement and documents last CF triggered patching
                ACTUAL_PATCH_DATE=$(date +%Y-%m-%d)
                MYINSTANCEID="$(wget -q -O - http://169.254.169.254/latest/meta-data/instance-id)"
                AWS_REGION="$(curl -s 169.254.169.254/latest/meta-data/placement/availability-zone | sed 's/.$//')"
                NAMEOFASG=$(aws ec2 describe-tags --region $AWS_REGION --filters {"Name=resource-id,Values=$MYINSTANCEID","Name=key,Values=aws:autoscaling:groupName"} --output=text | cut -f5)
                NAMEOFSTACK=${AWS::StackName}
                PATCHDONEFLAG=/root/patchingrebootwasdone.flg
                logit "Processing userdata script on instance: $MYINSTANCEID"
                logit "Operating in Region: $AWS_REGION, launched from ASG: $NAMEOFASG"
                yum update yum-utils yum-plugin-security
                uname -r
                if [ ! -z $NAMEOFASG ]; then
                  logit "Instance is in an ASG, will process lifecycle hooks"
                  logit "Listing hook to verify permissions and hook presence"
                  aws autoscaling describe-lifecycle-hooks --region $AWS_REGION --auto-scaling-group-name $NAMEOFASG
                else
                  logit "Instance is not in an ASG or if it is, the instance profile used does not have permissions to its own tags."
                fi

                if [ -f $PATCHDONEFLAG ]; then
                  logit "Completed a post-patching reboot, skipping patching check..."
                else
                  logit "Lets patch (including the kernel if necessary)..."
                  if [[ "${1OSPatchScope}" == "All" ]]; then
                    logit "Started Patching."
                    yum update -y
                    logit "Completed Patching."
                  elif [[ "${1OSPatchScope}" == "SecurityOnly" ]]; then
                    logit "Started Patching."
                    yum --security update -y
                    logit "Completed Patching."
                  elif [[ "${1OSPatchScope}" == "NoPatching-OnlyForDebugging" ]]; then
                    logit "No patching will be done - this setting is for debugging only (patch dates will still be set)"
                  fi
                  logit "ACTUAL_PATCH_DATE may be newer because this instance was autoscaled after the LAST_CF_PATCH_RUN"
                  logit "LAST_CF_PATCH_RUN: $LAST_CF_PATCH_RUN"
                  echo "export LAST_CF_PATCH_RUN=$LAST_CF_PATCH_RUN" >> /etc/profile.d/lastpatchingdata.sh
                  logit "ACTUAL_PATCH_DATE: $ACTUAL_PATCH_DATE"
                  echo "export ACTUAL_PATCH_DATE=$ACTUAL_PATCH_DATE" >> /etc/profile.d/lastpatchingdata.sh
                fi
                
                logit "Continuing..."
                if [ ! -z $NAMEOFASG ]; then
                  logit "Sending a heart beat to reset the timeout counter while doing more things (just as an example)..."
                  aws autoscaling record-lifecycle-action-heartbeat --region $AWS_REGION --instance-id $MYINSTANCEID --lifecycle-hook-name instance-patching-reboot --auto-scaling-group-name $NAMEOFASG
                fi

                if [[ "${8DBGSetupPseudoWebApp}" == "true" ]]; then
                  logit "Installing Web Application (To Emulate a Real Software Stack)"
                  yum install -y httpd
                  service httpd start
                  chkconfig httpd on
                  
                  cat << HTMLHomePage > /var/www/html/index.html
                  <html><head><title>CloudyWindows.io ASG With Lifecycle Hooks</title></head>
                  <body>
                  <h1>CloudyWindows.io ASG With Lifecycle Hooks</h1>
                  <p><A HREF="https://cloudywindows.io/post/asg-lifecycle-hook-for-linux-kernel-patching-with-a-reboot-in-aws-autoscaling-groups/"><IMG SRC="https://cloudywindows.io/mstile-150x150.png"> Check Out The Blog Post For This Template!</A>
                  <BR><BR>Page retrieved from load balanced instance: $MYINSTANCEID 
                  <BR>in ASG: $NAMEOFASG
                  <BR>As a part of CF Stack: ${AWS::StackName}
                  <BR>Running OS: ${1OSInstanceOSPlatform}                
                  <BR>with LAST_CF_PATCH_RUN: $LAST_CF_PATCH_RUN and ACTUAL_PATCH_DATE: $ACTUAL_PATCH_DATE</p>
                  <iframe src="https://cloudywindows.io" frameborder=0 width="100%" height="100%" ></iframe>
                  </body>
                  </html>
                HTMLHomePage
                fi

                #Check if already installed or running
                if [[ "${3INSTInstallCodeDeploy}" == "true" ]]; then
                  logit "Code Deploy Install..."
                  yum install -y ruby
                  cd /tmp
                  aws s3 cp s3://aws-codedeploy-us-east-1/latest/install . --region $AWS_REGION
                  chmod +x ./install
                  ./install auto
                fi

                #This approach for termination hook is much simpler than those involving SNS or CloudWatch, but when deployed 
                # on many instances it can result in a lot of ASG Describe API calls (which may be rate limited).
                ASGSelfMonitorTerminationInterval=${5ASGSelfMonitorTerminationInterval}
                if [ ! -z "$NAMEOFASG" ] && [ "$ASGSelfMonitorTerminationInterval" != "Disabled" ] && [ "$WaitingForReboot" != "true" ]; then
                  logit "Setting up termination monitoring because 5ASGSelfMonitorTerminationInterval is set to $ASGSelfMonitorTerminationInterval"
                  SCRIPTNAME=/etc/cron.d/MonitorTerminationHook.sh
                  SCRIPTFOLDER=$(dirname $SCRIPTNAME)
                  SCRIPTBASENAME=$(basename $SCRIPTNAME)
                  yum install -y jq
                  
                  #Heredoc script
                  cat << EndOfScript > $SCRIPTNAME
                    function logit() {
                      LOGSTRING="\$(date +"%_b %e %H:%M:%S") \$(hostname) TERMINATIONMON_SCRIPT: \$1"
                      echo "\$LOGSTRING"
                      echo "\$LOGSTRING" >> /var/log/messages
                    }
                    #These are resolved at script creation time to reduce api calls when this script runs every minute on instances.
               
                    if [[ "\$(aws autoscaling describe-auto-scaling-instances --instance-ids $MYINSTANCEID --region $AWS_REGION | jq --raw-output '.AutoScalingInstances[0] .LifecycleState')" == *"Terminating"* ]]; then
                      logit "This instance ($MYINSTANCEID) is being terminated, perform cleanup..."

                      #### PUT YOUR CLEANUP CODE HERE, DECIDE IF CLEANUP CODE SHOULD ERROR OUT OR SILENTLY FAIL (best effort cleanup)

                      aws autoscaling complete-lifecycle-action --region $AWS_REGION --lifecycle-action-result CONTINUE --instance-id $MYINSTANCEID --lifecycle-hook-name instance-terminating --auto-scaling-group-name $NAMEOFASG
                      logit "This instance ($MYINSTANCEID) is ready for termination"
                      logit "Lifecycle CONTINUE was sent to termination hook in ASG: $NAMEOFASG for this instance ($MYINSTANCEID)."
                    fi

                EndOfScript

                  logit "SCHEDULING: $SCRIPTNAME for every $ASGSelfMonitorTerminationInterval minutes to check for termination hook."

                  chown root:root "$SCRIPTNAME"
                  chmod 644 "$SCRIPTNAME"
                  logit "Adding cron job"
                  logit "*/$ASGSelfMonitorTerminationInterval * * * * root bash $SCRIPTNAME" | $SUDO tee -a /etc/crontab > /dev/null
                  chown root:root /etc/crontab
                  chmod 644 /etc/crontab
                fi

                DefaultLocalCachedConfigScript="custom_instance_configuration_script.sh"
                logit "##########################################"
                logit "RUNNING CUSTOM INSTANCE CONFIGURATION CODE"

                #If indicated as embedded, run it.
                if [[ "${3INSTConfigurationScript}" == "Embedded" ]]; then
                  logit "CUSTOM CONFIG: Running embedded custom instance configuration script."
                  #############################################
                  # YOUR CODE HERE
                  #############################################

                elif [[ "${3INSTConfigurationScript}" == "http://"* || "${3INSTConfigurationScript}" == "https://"* ]]; then
                  logit "CUSTOM CONFIG: Retrieving custom instance configuration script from ${3INSTConfigurationScript}"
                  if [ ! -f $DefaultLocalCachedConfigScript ]; then
                      logit "Pulling and executing from \"${3INSTConfigurationScript}\""
                      if [ -n "$(command -v curl)" ]; then
                          logit "found and using curl"
                          curl -o $DefaultLocalCachedConfigScript -s ${3INSTConfigurationScript}
                      elif [ -n "$(command -v wget)" ]; then
                          logit "found and using wget"
                          wget -O $DefaultLocalCachedConfigScript -s ${3INSTConfigurationScript}
                      else
                          logit "Could not find curl or wget, install one of these or manually copy \"${3INSTConfigurationScript}\""
                      fi
                  fi

                elif [[ "${3INSTConfigurationScript}" == "s3://"* ]]; then
                  logit "CUSTOM CONFIG: Retrieving custom instance configuration script from ${3INSTConfigurationScript}"
                  if [ ! -f $DefaultLocalCachedConfigScript ]; then
                      logit "Pulling and executing from \"${3INSTConfigurationScript}\""
                      aws s3 cp ${3INSTConfigurationScript} $DefaultLocalCachedConfigScript
                  fi
                else
                  logit "CUSTOM CONFIG: Running custom instance configuration script in the local file named ${3INSTConfigurationScript}"
                  if [ -f $DefaultLocalCachedConfigScript ]; then
                    logit "Pointing \$DefaultLocalCachedConfigScript to ${3INSTConfigurationScript}"
                    DefaultLocalCachedConfigScript=${3INSTConfigurationScript}
                  else
                    logit "${3INSTConfigurationScript} was not found, will error out."
                  fi
                fi

                if [ "${3INSTConfigurationScript}" != "Embedded" ]; then
                  logit "Execution of the Non-Embedded Instance Configuration Script \"$DefaultLocalCachedConfigScript\" has been requested."
                  if [ -f "$DefaultLocalCachedConfigScript" ]; then
                    source "$DefaultLocalCachedConfigScript"
                  else
                    logit "ERROR: $DefaultLocalCachedConfigScript was not found, but is needed to complete instance setup."
                    exit 9
                  fi
                fi

                # END OF "RUNNING CUSTOM INSTANCE CONFIGURATION CODE"
                # ###################################################

                needs-restarting -r 
                if [ $? -gt 0 ]; then
                  logit "Detected that a reboot is required, rebooting..."
                  logit "Resetting userdata semaphore..."
                  rm /var/lib/cloud/instances/*/sem/config_scripts_user
                  touch $PATCHDONEFLAG
                  reboot
                  logit "Waiting for reboot to complete..."
                  sleep 30
                  WaitingForReboot=true
                fi

                if [ ! -z "$NAMEOFASG" ] && [ "$WaitingForReboot" != "true" ]; then
                  logit "Completing lifecycle action hook so that ASG knows we are ready to be placed InService..."
                  aws autoscaling complete-lifecycle-action --region $AWS_REGION --lifecycle-action-result CONTINUE --instance-id $MYINSTANCEID --lifecycle-hook-name instance-patching-reboot --auto-scaling-group-name $NAMEOFASG
                fi
                
                if [ "$WaitingForReboot" != "true" ]; then
                  logit "Cfn-signaling success..."
                  /opt/aws/bin/cfn-signal --success true --stack ${AWS::StackName} --resource InstanceASG --region $AWS_REGION
                fi

                DBGCPULoadPercentInitialValue=${8DBGCPULoadPercentInitialValue}
                if [ "$WaitingForReboot" != "true" ] && [ -n "$DBGCPULoadPercentInitialValue" ]; then
                  logit "Setting up CPU stressing because 8DBGCPULoadPercentInitialValue was set to $DBGCPULoadPercentInitialValue"
                  if [[ ! -z "$(command -v amazon-linux-extras)" ]] ; then
                    amazon-linux-extras install epel -y
                  fi
                  yum install -y curl stress-ng
                  CPUPercent="$(aws --region=$AWS_REGION ssm get-parameter --name "$NAMEOFSTACK-SyntheticCPULoad" --output text --query Parameter.Value | grep -E ^\-?[0-9]+$)"
                  while [ "$CPUPercent" != '' ]; do
                    logit "Stressing for 1 minute at $CPUPercent percent CPU utilization before checking for updated percentage."
                    stress-ng -c 0 -l $CPUPercent --timeout 60
                    CPUPercent="$(aws --region=$AWS_REGION ssm get-parameter --name "$NAMEOFSTACK-SyntheticCPULoad" --output text --query Parameter.Value | grep -E ^\-?[0-9]+$)"
                  done
                  logit "Stopping CPU stressing due to receving non-numeric value: \"$(aws --region=$AWS_REGION ssm get-parameter --name "$NAMEOFSTACK-SyntheticCPULoad" --output text --query Parameter.Value)\""
                fi              
            - 
              # **************
              # Windows UserData
              Fn::Base64: !Sub | 
                <powershell>
                $AWSASGLabKitVersion="1.2"
                Function logit ($Msg, $MsgType='Information', $ID='1') {
                  If ($script:PSCommandPath -ne '' ) { $SourcePathName = $script:PSCommandPath ; $SourceName = split-path -leaf $SourcePathName } else { $SourceName = "Automation Code"; $SourcePathName = "Unknown" }
                  Write-Host "[$(Get-date -format 'yyyy-MM-dd HH:mm:ss zzz')] $MsgType : From: $SourcePathName : $Msg"
                  $applog = New-Object -TypeName System.Diagnostics.EventLog -argumentlist Application
                  $applog.Source="$SourceName"
                  $applog.WriteEntry("From: $SourcePathName : $Msg", $MsgType, $ID)
                }                
                logit "Building Instance... with AWS ASG Lab Kit Version: $AWSASGLabKitVersion"
                logit "Learn more at: $1AAAReadmeBlogPost"
                logit "On 2016 and later (Ec2Launch) errors are logged to cat C:\programdata\Amazon\EC2-Windows\Launch\Log\UserdataExecution.log" 
                logit "Rendered script on an instance will be found at: C:\Windows\TEMP\UserScript.ps1"               

                If ((![bool](get-process amazon-ssm-agent -ErrorAction SilentlyContinue)) -AND ($8DBGTroubleShootingMode -eq 'true')) {
                  logit "8DBGTroubleShootingMode is true and SSM is not present - Installing SSM for Session Manager Access..."
                  Invoke-WebRequest https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/windows_amd64/AmazonSSMAgentSetup.exe -OutFile $env:USERPROFILE\SSMAgent_latest.exe
                  Start-Process	-FilePath $env:USERPROFILE\SSMAgent_latest.exe -ArgumentList "/S"
                }              
                If (!(Test-Path "C:\Program Files\Amazon\AWSCLI\bin\aws.exe")) {
                  logit "Installing AWS CLI to control lifecycle hook updates..."
                  $AWSCLIURL="https://s3.amazonaws.com/aws-cli/AWSCLI64PY3.msi" #v1
                  #$AWSCLIURL="https://awscli.amazonaws.com/AWSCLIV2.msi" #v2
                  Invoke-WebRequest $AWSCLIURL -OutFile $env:USERPROFILE\AWSCLI.msi
                  Start-Process	 -wait -nonewwindow -FilePath "msiexec.exe" -ArgumentList "/i $env:USERPROFILE\AWSCLI.msi /l*v $env:USERPROFILE\\AWSCLI-install.log /qn"
                  $env:PATH="$env:PATH;C:\Program Files\Amazon\AWSCLI\bin"
                  #$env:PATH="$env:PATH;C:\Program Files\Amazon\AWSCLIV2"
                  If (![bool](get-command aws.exe)) {
                    throw "AWS CLI did not install correctly"
                  }
                }
                If (![bool](get-command cfn-signal.exe)) {
                  logit "cfn-bootstrap is not present, installing it to control cloud formation completion..."
                  Invoke-WebRequest https://s3.amazonaws.com/cloudformation-examples/aws-cfn-bootstrap-win64-latest.msi -OutFile $env:USERPROFILE\aws-cfn-bootstrap-win64-latest.msi
                  Start-Process	 -wait -nonewwindow -FilePath "msiexec.exe" -ArgumentList "/i $env:USERPROFILE\aws-cfn-bootstrap-win64-latest.msi /l*v $env:USERPROFILE\aws-cfn-bootstrap-win64-latest.log /qn"
                }
                Function Test-PendingReboot
                {
                  Return ([bool]((get-itemproperty "hklm:SYSTEM\CurrentControlSet\Control\Session Manager").RebootPending) -OR 
                  [bool]((get-itemproperty "HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update").RebootRequired) -OR 
                  [bool]((get-itemproperty "HKLM:SYSTEM\CurrentControlSet\Control\Session Manager").PendingFileRenameOperations) -OR 
                  ((test-path c:\windows\winsxs\pending.xml) -AND ([bool](get-content c:\windows\winsxs\pending.xml | Select-String 'postAction="reboot"'))) -OR 
                  ((get-itemproperty 'HKLM:SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\' | Select-Object -Expand 'ComputerName') -ine (get-itemproperty 'HKLM:SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\' | Select-Object -Expand 'ComputerName')) -OR 
                  ((Test-Path "HKLM:SYSTEM\CurrentControlSet\Services\Netlogon\JoinDomain") -OR (Test-Path "HKLM:SYSTEM\CurrentControlSet\Services\Netlogon\AvoidSpnSet")))
                }

                $INSTANCEOSPLATFORM=${1OSInstanceOSPlatform}
                $LAST_CF_PATCH_RUN="${1OSPatchRunDate}" #Forces change for patching rolling replacement and documents last CF triggered patching
                $ACTUAL_PATCH_DATE="$(date -format 'yyyy-MM-dd')"
                $MYINSTANCEID="$(invoke-restmethod http://169.254.169.254/latest/meta-data/instance-id)"
                $AWS_REGION="$($(invoke-restmethod 169.254.169.254/latest/meta-data/placement/availability-zone) -replace '.$')"
                $NAMEOFASG=$(aws ec2 describe-tags --region $AWS_REGION --filters Name=resource-id,Values=$MYINSTANCEID Name=key,Values=aws:autoscaling:groupName | convertfrom-json).tags.value
                $NAMEOFSTACK="${AWS::StackName}"
                $PATCHDONEFLAG="$env:USERPROFILE/patchingrebootwasdone.flg"
                $1OSPatchScopeToUse="${1OSPatchScope}"

                logit "Processing userdata script on instance: $MYINSTANCEID"
                logit "Operating in Region: $AWS_REGION, launched from ASG: $NAMEOFASG"
                if ($NAMEOFASG) {
                  logit "Instance is in an ASG, will process lifecycle hooks"
                  logit "Listing hook to verify permissions and hook presence"
                  aws --region $AWS_REGION autoscaling describe-lifecycle-hooks --auto-scaling-group-name $NAMEOFASG
                } else {
                  logit "Instance is not in an ASG or if it is, the instance profile used does not have permissions to its own tags."
                }

                if (Test-Path $PATCHDONEFLAG) {
                  logit "Completed a post-patching reboot, skipping patching check..."
                } else {
                  logit "Lets patch (including the kernel if necessary)..."
                  logit "IMPORTANT: Windows update only updates installed os components.  If you install a component like IIS after this, you will need to run the patching commands again."

                  if ((get-module -listavailable PSWindowsUpdate).count -lt 1) {
                    Write-Host "PSWindowsUpdate is not available, installing..."
                    install-module pswindowsupdate -SkipPublisherCheck -Force
                  }

                  Switch ($1OSPatchScopeToUse) {
                    "SecurityOnly" { logit "Starting Patching."; Install-WindowsUpdate -MicrosoftUpdate -Category "Security Updates" -AcceptAll -Verbose; logit "Completed Patching." }
                    "All" { logit "Starting Patching."; Install-WindowsUpdate -MicrosoftUpdate -AcceptAll -Verbose; logit "Completed Patching." }
                    "NoPatching-OnlyForDebugging" {logit -MsgType 'Warning' -ID 4 -Msg "No patching will be done - this setting is for debugging only (patch dates will still be set)" }
                  }

                  $LatestNGENBinary = $(Get-ChildItem $env:windir\microsoft.net\framework64\v*\ngen.exe | sort-object | select-object -last 1 | select-object -expand FullName)

                  If ($LatestNGENBinary) {
                    logit "Running Native Assembly Generation to process .NET updates immediately. Most errors can be ignored."
                    Start-Process $LatestNGENBinary -ArgumentList 'update' -nonewwindow -wait
                    logit "Native Assembly Generation Complete. Most errors can be ignored."
                  } else {
                    logit -MsgType 'Warning' -ID 7 "Warning ngen.exe was not found, which means .NET may not be installed - a highly unusual situation."
                  }
                  
                  logit "ACTUAL_PATCH_DATE may be newer because this instance was autoscaled after the LAST_CF_PATCH_RUN"
                  logit "LAST_CF_PATCH_RUN: $LAST_CF_PATCH_RUN"
                  set-content $env:public/lastpatchingdata.ps1 "$LAST_CF_PATCH_RUN=$LAST_CF_PATCH_RUN"
                  logit "ACTUAL_PATCH_DATE: $ACTUAL_PATCH_DATE"
                  add-content $env:public/lastpatchingdata.ps1 "$ACTUAL_PATCH_DATE=$ACTUAL_PATCH_DATE"
                }

                if ("${8DBGSetupPseudoWebApp}" -eq "true") {
                  logit "Installing Web Application (To Emulate a Real Software Stack), Chocolatey is installed to support this test setup."
                  If (!(Test-Path env:chocolateyinstall)) {Invoke-WebRequest https://chocolatey.org/install.ps1 -UseBasicParsing | Invoke-Expression }
                  choco install -y apache-httpd --params '"/installLocation:C:\HTTPD /port:80"'
                  
                  Set-Content -Path 'C:\HTTPD\Apache24\htdocs\index.html' -Value @"
                  <html><head><title>CloudyWindows.io ASG With Lifecycle Hooks</title></head>
                  <body>
                  <h1>CloudyWindows.io ASG With Lifecycle Hooks</h1>
                  <p><A HREF="https://cloudywindows.io/post/asg-lifecycle-hook-for-linux-kernel-patching-with-a-reboot-in-aws-autoscaling-groups/"><IMG SRC="https://cloudywindows.io/mstile-150x150.png"> Check Out The Blog Post For This Template!</A>
                  <BR><BR>Page retrieved from load balanced instance: $MYINSTANCEID 
                  <BR>in ASG: $NAMEOFASG
                  <BR>As a part of CF Stack: ${AWS::StackName}
                  <BR>Running OS: ${1OSInstanceOSPlatform}
                  <BR>with LAST_CF_PATCH_RUN: $LAST_CF_PATCH_RUN and ACTUAL_PATCH_DATE: $ACTUAL_PATCH_DATE</p>
                  <iframe src="https://cloudywindows.io" frameborder=0 width="100%" height="100%" ></iframe>
                  </body>
                  </html>
                "@
                }

                if (("${3INSTInstallCodeDeploy}" -eq "true") -AND (![bool](get-service codedeployagent -ErrorAction SilentlyContinue))) {
                  logit "Code deploy is requested, but not present, installing CodeDeploy"
                  aws s3 cp s3://aws-codedeploy-$AWS_REGION/latest/codedeploy-agent.msi $env:USERPROFILE\codedeploy-agent.msi  --region $AWS_REGION
                  Start-Process	 -wait -nonewwindow -FilePath "msiexec.exe" -ArgumentList "/i $env:USERPROFILE\codedeploy-agent.msi /l*v $env:USERPROFILE\codedeploy-agent.log /qn"
                }

                #This approach for termination hook is much simpler than those involving SNS or CloudWatch, but when deployed 
                # on many instances it can result in a lot of ASG Describe API calls (which may be rate limited).
                # variables identifying the instance and asg are hard coded into the script to reduce api calls.
                $ASGSelfMonitorTerminationInterval=${5ASGSelfMonitorTerminationInterval}
                if ($NAMEOFASG -AND ($ASGSelfMonitorTerminationInterval -ne "Disabled") -AND (!$WaitingForReboot -eq $True)) {
                  logit "Setting up termination monitoring because 5ASGSelfMonitorTerminationInterval is set to $ASGSelfMonitorTerminationInterval"
                  $SCRIPTNAME="$env:public\MonitorTerminationHook.ps1"
                  
                  #Heredoc script
                  set-content $SCRIPTNAME -Value @"
                    Function logit (`$Msg, `$MsgType='Information', `$ID='1') {
                      If (`$script:PSCommandPath -ne '' ) { `$SourcePathName = `$script:PSCommandPath ; `$SourceName = split-path -leaf `$SourcePathName } else { `$SourceName = "Automation Code"; `$SourcePathName = "Unknown" }
                      Write-Host "[`$(Get-date -format 'yyyy-MM-dd HH:mm:ss zzz')] `$MsgType : From: `$SourcePathName : `$Msg"
                      `$applog = New-Object -TypeName System.Diagnostics.EventLog -argumentlist Application
                      `$applog.Source="`$SourceName"
                      `$applog.WriteEntry("From: `$SourcePathName : `$Msg", `$MsgType, `$ID)
                    }
                
                    if ( (aws autoscaling describe-auto-scaling-instances --instance-ids $MYINSTANCEID --region $AWS_REGION | convertfrom-json).AutoScalingInstances.LifecycleState -ilike "*Terminating*" ) {
                      logit "This instance ($MYINSTANCEID) is being terminated, perform cleanup..."

                      #### PUT YOUR CLEANUP CODE HERE, DECIDE IF CLEANUP CODE SHOULD ERROR OUT OR SILENTLY FAIL (best effort cleanup)

                      aws autoscaling complete-lifecycle-action --region $AWS_REGION --lifecycle-action-result CONTINUE --instance-id $MYINSTANCEID --lifecycle-hook-name instance-terminating --auto-scaling-group-name $NAMEOFASG
                      logit "This instance ($MYINSTANCEID) is ready for termination"
                      logit "Lifecycle CONTINUE was sent to termination hook in ASG: $NAMEOFASG for this instance ($MYINSTANCEID)."
                    }

                "@

                  logit "SCHEDULING: $SCRIPTNAME for every $ASGSelfMonitorTerminationInterval minutes to check for termination hook."
                  schtasks.exe /create /sc MINUTE /MO $ASGSelfMonitorTerminationInterval /tn "MonitorTerminationHook.ps1" /ru SYSTEM /tr "powershell.exe -file $SCRIPTNAME"

                }

                $DefaultLocalCachedConfigScript="$env:public\custom_instance_configuration_script.ps1"
                $INSTConfigurationScript="${3INSTConfigurationScript}"
                logit "####"
                logit "RUNNING CUSTOM INSTANCE CONFIGURATION CODE"

                #If indicated as embedded, run it.
                if ( $INSTConfigurationScript -eq "Embedded" ) {
                  logit "CUSTOM CONFIG: Running embedded custom instance configuration script."
                  ######
                  # YOUR INSTANCE CONFIG CODE HERE

                } elseif (($INSTConfigurationScript -ilike "http://*") -OR ($INSTConfigurationScript -ilike "https://*" )) {
                  logit "CUSTOM CONFIG: Retrieving custom instance configuration script from $INSTConfigurationScript"
                  if (!(Test-Path $DefaultLocalCachedConfigScript)) {
                      logit "Pulling and executing from `"$INSTConfigurationScript`""
                      [Net.ServicePointManager]::SecurityProtocol = "tls12, tls11, tls"
                      Invoke-RestMethod -OutFile $DefaultLocalCachedConfigScript -Uri $INSTConfigurationScript
                    }
                } elseif ( $INSTConfigurationScript -ilike "s3://*" ) {
                  logit "CUSTOM CONFIG: Retrieving custom instance configuration script from $INSTConfigurationScript"
                  if (!(Test-Path $DefaultLocalCachedConfigScript)) {
                      aws s3 cp $INSTConfigurationScript $DefaultLocalCachedConfigScript
                  } else {
                    logit "$DefaultLocalCachedConfigScript was not found, will error out."
                  }                  
                } else {
                  logit "CUSTOM CONFIG: Running custom instance configuration script in the local file named $INSTConfigurationScript"
                  if (!(Test-Path $DefaultLocalCachedConfigScript)) {
                    logit "Pointing \$DefaultLocalCachedConfigScript to $INSTConfigurationScript"
                    DefaultLocalCachedConfigScript=$INSTConfigurationScript
                  } else {
                    logit "$DefaultLocalCachedConfigScript was not found, will error out."
                  }
                }

                if ( $INSTConfigurationScript -ne "Embedded") {
                  logit "Execution of the Non-Embedded Instance Configuration Script `"$DefaultLocalCachedConfigScript`" has been requested."
                  if (Test-Path $DefaultLocalCachedConfigScript) {
                    . "$DefaultLocalCachedConfigScript"
                  } else {
                    throw "ERROR: $DefaultLocalCachedConfigScript was not found, but is needed to complete instance setup."
                    exit 9
                  }
                }
                # END OF CUSTOM INSTANCE CONFIGURATION CODE"

                If (Test-PendingReboot)
                  {
                    logit "Reboot pending, shutting down in 10 seconds (giving time for orchestrating automation to close out)..."
                    $WaitingForReboot=$True
                    logit "Ensuring userdata will be processed again"
                    $path = 'C:\Program Files\Amazon\Ec2ConfigService\Settings\config.xml'
                    if (Test-Path $path) {
                      logit "Reseting Ec2Config userdata"
                      $xml = [xml](Get-Content $path)
                      $state = $xml.Ec2ConfigurationSettings.Plugins.Plugin | where {$_.Name -eq 'Ec2HandleUserData'}
                      $state.State = 'Disabled'
                      $xml.Save($path)
                    }
                    $path = 'C:\ProgramData\Amazon\Ec2-Windows\Launch\Config\LaunchConfig.json'
                    if (Test-Path $path) {
                      $ec2launchconfig = get-content $path | convertfrom-json
                      if (!$($ec2launchconfig.handleUserData)) {
                        logit "Reseting Ec2Launch userdata"
                        $ec2launchconfig.handleUserData = $True
                        $ec2launchconfig | convertto-json | set-content $path
                      }
                    }
                    shutdown.exe /r /t 10
                  } Else {
                    Write-Host "A reboot is not pending, no action taken."
                  }


                if ($NAMEOFASG -AND !$WaitingForReboot) {
                  logit "Completing lifecycle action hook so that ASG knows we are ready to be placed InService..."
                  aws autoscaling complete-lifecycle-action --region $AWS_REGION --lifecycle-action-result CONTINUE --instance-id $MYINSTANCEID --lifecycle-hook-name instance-patching-reboot --auto-scaling-group-name $NAMEOFASG
                }
                
                if (!$WaitingForReboot) {
                  logit "Cfn-signaling success..."
                  cfn-signal --success true --stack ${AWS::StackName} --resource InstanceASG --region $AWS_REGION
                }

                $DBGCPULoadPercentInitialValue=${8DBGCPULoadPercentInitialValue}
                if (($WaitingForReboot -ne $True ) -AND ($DBGCPULoadPercentInitialValue)) {
                  logit "Setting up CPU stressing because 8DBGCPULoadPercentInitialValue was set to $DBGCPULoadPercentInitialValue"
                  Invoke-WebRequest https://github.com/vikyd/go-cpu-load/releases/download/0.0.1/go-cpu-load-win-amd64.exe -UseBasicParsing -outfile go-cpu-load-win-amd64.exe
                  $CPUPercent="$(aws --region=$AWS_REGION ssm get-parameter --name $NAMEOFSTACK-SyntheticCPULoad --output text --query Parameter.Value)"
                  while ( $CPUPercent -match "^[\d\.]+$" ) {
                    logit "Stressing for 1 minutes at $CPUPercent percent CPU utilization."
                    . .\go-cpu-load-win-amd64.exe -p $CPUPercent -t 60
                    $CPUPercent="$(aws --region=$AWS_REGION ssm get-parameter --name $NAMEOFSTACK-SyntheticCPULoad --output text --query Parameter.Value)"
                  }
                  logit "Stopping CPU stressing due to receving non-numeric value: `"$CPUPercent`""
                }
                </powershell>              