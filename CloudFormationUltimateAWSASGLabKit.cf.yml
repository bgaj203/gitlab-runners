---
AWSTemplateFormatVersion: '2010-09-09'
Description: >
  NOTE: If you are allowing autocreation of a bucket, the stack name is used in the bucketname an only lowercase letters are allowed in bucket names.
Parameters:
  1AAAAUltimateASGVersion:
    Description: "Read Only - GitLab Runner Autoscaling on AWS with Spot Support."
    Type: String
    Default: "2.3.0"
    AllowedValues: [ "2.3.0" ]
    ConstraintDescription: "Version number is used in the template and cannot be changed."
  1AAAReadmeBlogPost:
    Description: Read the following post to learn why this template is helpful - Darwin.
    Type: String
    Default: https://gitlab.com/guided-explorations/gitlab-deployment/gitlab-runner-autoscaling-aws-asg/-/blob/master/README.md
    AllowedValues: [ "https://gitlab.com/guided-explorations/gitlab-deployment/gitlab-runner-autoscaling-aws-asg/-/blob/master/README.md" ]
    ConstraintDescription: "Readme Blog post is for documentation purposes only and cannot be changed."
  1OSPeggedAMIID:
    Description: >
      99% of the time you will want to leave this as "latest".  Override here if you have a dependency on a specific AMI or have prepared a custom one.
      Can be Windows or Linux, but the value choosen for 1OSInstanceOSPlatform must match the OS platform contained in the AMI.
      For testing pick an older one that will need a kernel patch or other reboot required patch for sure.
      For Linux - due to optimization and AWS ECR Creds Helper, Amazon Linux 2 is assumed, but other Redhat parentage distros may work (yum packager).
      CentOS7 (use M4): ami-4bf3d731.
    Type: String
    Default: AlwaysUseLatest
  1OSInstanceOSPlatform:
    Description: >
      Enter "Linux" or "Windows".  AMI specified in 9AWSRetrieveLatestAWSOSAmiIdFromSSM or 1OSPeggedAMIID must contain this platform choice.
    Type: String
    Default: Linux
    #Reset above to: Linux
    AllowedValues: 
      - Linux
      - Windows
  1OSPatchRunDate:
    Description: >
      Enter the deploy or update date - changing this is required to force a rolling replacement for patching.
      It has a secondary purpose as a convenient way to document the patch date as an environment variable and an EC2 tag.  
      It is just a string that you could set to any value and has no role in selecting patches or anything else - but it 
      does need to change from it's previous setting in order for the update to be forced.
    Type: String
    Default: 2019-06-04
  1OSPatchScope:
    Description: What types of patches to apply
    Type: String
    Default: NoPatching-OnlyForDebugging
    #Reset above to: All
    AllowedValues: 
      - All
      - SecurityOnly
      - NoPatching-OnlyForDebugging   
      #For "NoPatching-OnlyForDebugging" - No patching will be done - this setting is for debugging only (patch dates will still be set)   
  3INSTConfigurationScript:
    Description: >
      Allows additional script commands during startup. This is parameterized for testing new versions and to enable one
      CloudFormation template codebase to be used for many different Autoscaling groups. It also allows you to use this template
      without customizing it so that you can take future updates without headache. Windows 2012 and earlier also have a userdata size
      limit of 16Kb - this method gets around that.
      1) "Embedded" uses the code right in this template and does not use external files at all.
      2) Enter a URL starting with s3://, http:// or https:// to dynamically source one during instance provisioning.
      s3 allows easy private file storage.  http/s enables usage of git raw urls (whether public or private).
      3) Enter a file pathname on the local instance. The file must be present in the location by the time Userdata processes
      (e.g. via a custom AMI)
      The instance must have a network route and permission to any remote locations.
      The code you write must be idempotent so that it does the correct thing when run again after a patching reboot.
      There is an example at: https://gitlab.com/DarwinJS/ultimate-aws-asg-lab-kit/-/raw/master/CustomInstanceConfigurationScriptSample.sh_and_ps1
    Type: String
    Default: https://gitlab.com/guided-explorations/aws/gitlab-runner-autoscaling-aws-asg/-/raw/master/runner_configs/amazon-linux-2-docker.sh
    #Reset above to: https://gitlab.com/guided-explorations/aws/gitlab-runner-autoscaling-aws-asg/-/raw/master/runner_configs/amazon-linux-2-docker.sh
  3INSTInstallCodeDeploy:
    Description: Installs CodeDeploy so it can be used for initial deployments and updates.
    Type: String
    Default: false
    AllowedValues: 
      - true
      - false 
  3GITLABRunnerExecutor:
    Description: Type of runner executor
    Type: String
    Default: docker
    #Reset to: docker
    AllowedValues: 
      - shell
      - docker
      - docker+machine 
  3GITLABRunnerInstanceURL:
    Description: >
      The url of the instance that the runner will register (must be reachable from runner instance on port 443 with return conversations).
    Type: String
    Default: https://gitlab-core.us.gitlabdemo.cloud/
    #Reset to: https://gitlab.com
  3GITLABRunnerTagList:
    Description: > 
      Supplemental tags to identify the runner (comma delimited) in GitLab and AWS Instance tags.  
      The runner will automatically have tags for the operating system platform,whether or not the compute is spot or ondemand and the executor type.
      Ec2 tags will also include the runner name and the gitlab instance url.
    Type: String
    Default: TagA,TagB  
  3GITLABRunnerRegTokenList:
    Description: One or more runner tokens to register (comma delimited)
    Type: String
  3GITLABRunnerVersion:
    Description: Version of the GitLab Runner to install (defaults to latest)
    Type: String
    Default: latest
  4ASGDesiredCapacity:
    Description: >
      This template uses ASGs for HA - even if you choose not to autoscale.
      Desired capacity of 1 enables HOT/WARM through ASG Respawn.  Use this for applications where there CANNOT be more than one instance of this server/service role.
      Desired capacity of 2 enables HOT/HOT since loss of a node does not require respawn for recovery, but the application must support more than one instance of this server/service role.
      For testing, a desired capacity of 4 is a good number for testing rolling updates.  
      For testing all other functionality 1 is sufficient to observe how the userdata code processes to accomplish the yum update and reboot before the lifecycle hook.
    Type: Number
    Default: 2
    #Reset above to: 1
  4ASGUpdateType:
    Description: (Only Applies To Updates) Whether ASG Update Should Do a Rolling Update or an ASG Replacement.
    Type: String
    Default: RollingThroughInstances
    AllowedValues: 
      - ReplaceEntireASG
      - RollingThroughInstances
  4ASGScheduledShutdownCron:
    Description: >
      Cron format when ASG should scale to 0 for Min and Desired. to completely stop all instances. This is UTC, so adjust for your timezone.
      You can set only a stop hour if something else is starting the ASG on demand, but this action will also scale it to the new parameters 
      regardless of the current settings due to autoscaling. You can manually edit this template to add more schedules.
      For syntax guidelines see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions
      "0 19 * * MON-FRI" = Stop 7pm UTC, Monday-Friday. (Off during the UTC weekend)
      "0 20 * * *" = Stop 8pm UTC everyday.
    Type: String
    Default: Disabled 
  4ASGScheduledStartupCron:
    Description: >
      Cron format when ASG should scale to 1 minimum to start ASG, autoscaling will take over after start. This is UTC, so adjust for your timezone.
      You can set only a start hour if something else is stopping the ASG on demand, but this action will also scale it to the new parameters 
      regardless of the current settings due to autoscaling. You can manually edit this template to add more schedules.
      For syntax guidelines see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions
      "0 7 * * MON-FRI" = Start 7am UTC, Monday-Friday.
      "0 5 * * *" = Start 5am UTC everyday.
    Type: String
    Default: Disabled
  4ASGScheduledStartupDesiredInstances:
    Description: >
      How many desired instances should be started upon scheduled start.  Min will be set 1.  If autoscaling is in use, it will adjust shortly after.
      If autoscaling is not in use, this parameter dictates number of available instances when using schedules.
      Not used if 4ASGScheduledStartupCron = Disabled.
    Type: Number
    Default: 1
  5ASGAutoScalingEnabled:
    Description: >
      Setting to false still allows for High Availability - either HOT/Warm HA with 1 instance or HOT/HOT HA for 2 or more instances. 
      AWS resources for autoscaling are not created if this is false. The 'step scaling' policy is used.
    Type: String
    Default: true
    AllowedValues: 
      - true
      - false
  5ASGAutoScalingMaxSize:
    Description: >
      Maximum number of instances the ASG can contain.
    Type: Number
    Default: 10
  5ASGSelfMonitorTerminationInterval:  
    Description: >
      How often in minutes should the instance check if it is being asked to terminate so it can run a clean up script.
      Terminations initiated by spot occur two minutes after notification, so this value should less than that for spot implementations.
      AWS and instance resources for monitoring termination are not created if this value is not provided.
      It is best practice to delete this if a termination hook truely is not needed for cleanup.
    Type: String
    Default: 1
    AllowedValues: [0,1,2,3,4,5,Disabled] 
  5ASGSelfMonitorTerminationInterval:  
    Description: >
      How often in minutes should the instance check if it is being asked to terminate so it can run a clean up script.
      Terminations initiated by spot occur two minutes after notification, so this value should less than that for spot implementations.
      AWS and instance resources for monitoring termination are not created if this value is not provided.
      It is best practice to delete this if a termination hook truely is not needed for cleanup.
    Type: String
    Default: 1
    AllowedValues: [0,1,2,3,4,5,Disabled] 
  5ASGAutoScalingSetScaleOutCPUThreshold:
    Description: >
      What ASG-wide CPU threshold triggers scaling up via step-scaling? Requires 5ASGAutoScalingEnabled=true.
    Type: Number
    Default: 70  
  5ASGAutoScalingSetScaleOutCPUThresholdSeconds:
    Description: >
      How many seconds does the threshold have to be in alarm to trigger scale up via step-scaling? Requires 5ASGAutoScalingEnabled=true.
    Type: Number
    Default: 60     
  5ASGAutoScalingSetScaleInCPUThreshold:
    Description: >
      What ASG-wide CPU threshold triggers scaling down via step-scaling? Requires 5ASGAutoScalingEnabled=true.
    Type: Number
    Default: 20  
  5ASGAutoScalingSetScaleInCPUThresholdSeconds:
    Description: >
      How many seconds does the threshold have to be in alarm to trigger scale down? Requires 5ASGAutoScalingEnabled=true.
    Type: Number
    Default: 60
  5ASGBucketName:
    Description: >
      A bucket to which all instances will be given read and write permissions for purposes such as CodeDeploy, SSM Remote Command and Inventory.
      Values: "none" - do not create bucket or permissions. 
      "CreateOneForMe" - create a new, ASG unique bucket and permissions. Uses the stack name, which then must be all lowercase for the bucket to create properly. 
      "SpecificName" - presumed to be a preexisting bucket to which read / write permissions are already present. Generally used
      with a customer override IAM Instance Profile Role.
    Type: String
    Default: CreateOneForMe        
  5SPOTInstanceType1:
    Description: >
      ATTENTION: DISABLING SPOT *instance usage* is achieved by setting 5SPOTOnDemandPercentageAboveBaseCapacity to 0 (zero).
      It still results in a spot setup, but none of the instances will be spot instances.
      At least one instancetype is required, use at least 2 to demonstrate spot. You do not have to keep your instance
      sizes small because the lowest price will always be choosen and is likely cheaper than small on demand instances.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
    Default: "m4.large"
    AllowedPattern: ^[A-Za-z0-9.]+$
    ConstraintDescription: At least two instancetypes are required, use at least 2 to demonstrate spot.
  5SPOTInstanceType2:
    Description: >
      At least one instancetype is required, use at least 2 to demonstrate spot. You do not have to keep your instance
      sizes small because the lowest price will always be choosen and is likely cheaper than small on demand instances.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
    Default: "m5.large"
    #Remove Default
  5SPOTInstanceType3:
    Description: >
      At least one instancetype is required, use at least 2 to demonstrate spot. You do not have to keep your instance
      sizes small because the lowest price will always be choosen and is likely cheaper than small on demand instances.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
  5SPOTInstanceType4:
    Description: >
      At least one instancetype is required, use at least 2 to demonstrate spot. You do not have to keep your instance
      sizes small because the lowest price will always be choosen and is likely cheaper than small on demand instances.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
  5SPOTSpotAllocationStrategy:
    Description: >
      Determines which allocation strategy to use. 'capacity-optimized' helps reduce spot terminations.
      More information: https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_InstancesDistribution.html
    Type: String
    Default: lowest-price
    AllowedValues: 
      - lowest-price
      - capacity-optimized      
  5SPOTOnDemandBaseCapacity:
    Description: >
      Sets a minimum number of always on on-demand (non-spot) base capacity.  The number of instances here will benefit from InstanceType 
      exhaustion, but not spot pricing. Set to 0 for a 100% spot cluster.
    Type: Number
    Default: 1
    #Reset above to: 0
  5SPOTOnDemandPercentageAboveBaseCapacity: 
    Description: >
      ATTENTION: DISABLING SPOT *instance usage* is achieved by setting this value to 100 (zero). It still results in a spot setup, but none of
      the instances will be spot instances.
      What percent of the cluster should be Spot (with the remainder being on demand).  Percentage only applied to instances started after
      count in 5SPOTOnDemandBaseCapacity.
      Set to 0 for a 100% spot cluster.
    Type: Number
    Default: 100
    #Reset above to: 0    
  8DBGCPULoadPercentInitialValue:
    Description: >
      WARNING: Everything is 1 minute granularity - so don't set this to cause scaling and forget it unless you want a massive AWS bill ;)
      Test your scaling parameters with synthetic cpu loading.  Enabled by entering a numeric value between 20-95.
      This will create an SSM parameter named {AWS::Stackname}-SyntheticCPULoad with the initial value entered here.
      The userdata script will then run a CPU stressing utility in a loop, checking the parameter every minute for
      updated values.  The value updates the CPU consumption in all ASG members so you can observe whether your scaling
      policy works.  Set to a non-numeric value to terminate the Synthetic Loading (cannot be reenabled without rebuilding stack).
      AWS Resources are only created to support this functionality if a value is provided during stack deployment.
      The utility for Windows has a challenge generating loads above 90 percent, if you have a better cli utility, I'm all ears.
      For parameters above that range, setup your steps below 90 and test them and then once verified, update the numbers to the
      higher values.
    Type: String
  8DBGKeypairName:
    Description: Spins instances with a keypair to allow connection. Not needed if TroubleShootingMode is enabled.
    Type: String
  8DBGTroubleShootingMode:
    Description: Enables troubleshooting - enables SSM and configures Instance Profile IAM so SSM Session Manager can logon.
    Type: String
    Default: true
    #Reset above to: false
    AllowedValues: 
      - true
      - false     
  9AWSSpecifiedIAMRoleNAME:
    Description: >
      Uses the specified IAM Role as the Instance Profile rather than building one. Must be the Role NAME (NOT THE ARN) which 
      allows abstracted reuse of the same name across multiple AWS accounts. 'CreateOneForMe' causes this template to create a role for you.
      IMPORTANT: For scaling and lifecycle hooks to work, a prebuilt role must contain at least the permissions specified in this template in
      the resource sections: ASGRebootRole, ASGSelfAccessPolicy and EC2SelfAccessPolicy.
    Type: String
    Default: CreateOneForMe
  9AWSRetrieveLatestAWSOSAmiIdFromSSM:
    Description: >
      Get LATEST AMI Build by AWS as of Template run. Set to SSM parameter path. Only used if 1OSPeggedAMIID is set to 'latest'. 
      PARAMETER STORE PATHS HAVE MANY MORE OPTIONS FOR WINDOWS AND QUITE A FEW FOR AMAZON LINUX
      COMMAND TO FIND WINDOWS OPTIONS (You are NOT restricted to ones that have docker preinstalled): aws ssm get-parameters-by-path 
      --path '/aws/service/ami-windows-latest' --region us-east-1 | grep 'Server.*English.*Containers' 
      COMMON WINDOWS OPTIONS: /aws/service/ami-windows-latest/Windows_Server-2012-R2_RTM-English-64Bit-Base,
      /aws/service/ami-windows-latest/Windows_Server-2012-R2_RTM-English-64Bit-Core,/aws/service/ami-windows-latest/Windows_Server-2016-English-Core-ContainersLatest,
      /aws/service/ami-windows-latest/Windows_Server-2016-English-Full-ContainersLatest,/aws/service/ami-windows-latest/Windows_Server-2019-English-Core-ContainersLatest,
      /aws/service/ami-windows-latest/Windows_Server-2019-English-Full-ContainersLatest,/aws/service/ami-windows-latest/Windows_Server-1903-English-Core-ContainersLatest,
      /aws/service/ami-windows-latest/Windows_Server-1809-English-Core-ContainersLatest
      COMMON LINUX OPTIONS: /aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id (with docker), /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2 (no docker)
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id'
    #Reset above to: '/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2'
Conditions: 
  CreateDebugResources: !Equals [ !Ref 8DBGTroubleShootingMode, "true" ]
  ReplaceEntireASG: !Equals [ !Ref 4ASGUpdateType, "ReplaceEntireASG" ]
  InstancePlatformLinux: !Equals [ !Ref 1OSInstanceOSPlatform, "Linux" ]
  UseLatestAMI: !Equals [ !Ref 1OSPeggedAMIID, "AlwaysUseLatest"]
  BuildInstanceRoleToUse: !Equals [ !Ref 9AWSSpecifiedIAMRoleNAME, "CreateOneForMe" ]
  ConfigureAutoscaling: !Equals [ !Ref 5ASGAutoScalingEnabled, "true" ]
  SetupSythenticCPULoad: !Not [ !Equals [ !Ref 8DBGCPULoadPercentInitialValue, "" ]]
  Provided5SPOTInstanceType1: !Not [ !Equals [ !Ref 5SPOTInstanceType1, "" ]]
  Provided5SPOTInstanceType2: !Not [ !Equals [ !Ref 5SPOTInstanceType2, "" ]]
  Provided5SPOTInstanceType3: !Not [ !Equals [ !Ref 5SPOTInstanceType3, "" ]]
  Provided5SPOTInstanceType4: !Not [ !Equals [ !Ref 5SPOTInstanceType4, "" ]]
  UseKeypair: !Not [ !Equals [ !Ref 8DBGKeypairName, "" ]]
  EnableSelfTerminationMonitoring: !Not [ !Equals [ !Ref 5ASGSelfMonitorTerminationInterval, "Disabled" ]]
  CreateS3BucketAndPermissions: !Equals [ !Ref 5ASGBucketName, "CreateOneForMe" ]
  CreateStartSchedule: !Not [ !Equals [ !Ref 4ASGScheduledStartupCron, "Disabled" ]]
  CreateStopSchedule: !Not [ !Equals [ !Ref 4ASGScheduledShutdownCron, "Disabled" ]]

Rules:
  WindowsPlatformShouldNotUseDefaultSSMParameter:
    RuleCondition: !Equals [ !Ref 1OSInstanceOSPlatform, "Windows" ]
    Assertions:
      - Assert: !Not [ !Equals [ !Ref 9AWSRetrieveLatestAWSOSAmiIdFromSSM, "/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2" ]]
        AssertDescription: "You have indicated the Windows platform in the parameter 1OSInstanceOSPlatform, but left the default Linux SSM Parameter path in 9AWSRetrieveLatestAWSOSAmiIdFromSSM"
    RuleCondition: !Equals [ !Ref 1OSInstanceOSPlatform, "Windows" ]
    Assertions:
      - Assert: !Not [ !Equals [ !Ref 9AWSRetrieveLatestAWSOSAmiIdFromSSM, "/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2" ]]
        AssertDescription: "You have indicated the Windows platform in the parameter 1OSInstanceOSPlatform, but left the default Linux SSM Parameter path in 9AWSRetrieveLatestAWSOSAmiIdFromSSM"

Resources:
  #IAM Policies for Instance Profile:
  ASGInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Condition: BuildInstanceRoleToUse
    Properties:
      Path: /
      Roles: [ !Ref ASGRebootRole ]

  ASGSelfAccessPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Allow instances to read their own ASG information for finding and signalling lifecycle hooks.    
      ManagedPolicyName: !Sub "${AWS::StackName}-ASGSelfAccessPolicy"
      PolicyDocument:
        Version: 2012-10-17
        Statement:
        - Sid: ASGSelfAccessPolicy
          Resource: "*"
          Effect: Allow
          Action:
            - iam:ListAccountAliases
            - autoscaling:DescribeAutoScalingInstances
            - autoscaling:DescribeAutoScalingGroups
            - autoscaling:DescribeLifecycle*                   
        - Sid: ASGLifeCycleAccessPolicy
          Resource: !Sub 'arn:${AWS::Partition}:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/${AWS::StackName}*'
          Effect: Allow
          Action:
            - autoscaling:CompleteLifecycleAction
            - autoscaling:RecordLifecycleActionHeartbeat
          #To use a tag condition, update Resource to '*' and uncomment this segement
          #Condition:
          #  StringEquals:
          #    autoscaling :ResourceTag/Name: !Ref AWS::StackName

  EC2SelfAccessPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Allow instances to read their own information - for detecting asg and spot membership.
      ManagedPolicyName: !Sub "${AWS::StackName}-EC2SelfAccessPolicy"
      PolicyDocument:
        Version: 2012-10-17
        Statement:
        - Sid: EC2SelfAccessPolicy
          Resource: "*"
          Effect: Allow
          Action: 
            - ec2:DescribeInstances
            - ec2:DescribeTags
  
  ASGBucketPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Setting Amazon S3 bucket policy for ASG Instance Access for CodeDeploy and SSM.
      ManagedPolicyName: !Sub "${AWS::StackName}-ASGBucketPolicy"
      PolicyDocument:
        Version: 2012-10-17
        Statement:
        - Action:
            - 's3:GetObject'
            - 's3:GetObjectVersion'
            - 's3:GetBucketVersioning'
            - 's3:PutObject'            
          Resource:
            !If
              - CreateS3BucketAndPermissions
              - 
                - !Sub 'arn:${AWS::Partition}:s3:::${ASGBucket}'
                - !Sub 'arn:${AWS::Partition}:s3:::${ASGBucket}/*'       
              -             
                - !Sub 'arn:${AWS::Partition}:s3:::${5ASGBucketName}'
                - !Sub 'arn:${AWS::Partition}:s3:::${5ASGBucketName}/*'
          Effect: Allow
          Sid: WhitelistedGet

  #Give access to CPU Percent for ASG Scaling Testing
  #Because hacking together a conditional dependency in CF is a lot of extra code, this policy is always created (not least config)
  SSMParameterStorePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      ManagedPolicyName: !Sub "${AWS::StackName}-SSMParameterStorePolicy"
      PolicyDocument:
        Version: 2012-10-17
        Statement:
        - Sid: SSMParameterStorePolicy
          Resource: !Sub "arn:aws:autoscaling:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}-SyntheticCPULoad"
          Effect: Allow
          Action: 
            - ssm:GetParameters

  ASGRebootRole:
    Type: AWS::IAM::Role
    Condition: BuildInstanceRoleToUse
    DependsOn:
      - ASGSelfAccessPolicy
      - EC2SelfAccessPolicy
      - ASGBucketPolicy
      - SSMParameterStorePolicy    
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Action: sts:AssumeRole
          Principal:
            Service:
              - ec2.amazonaws.com
      ManagedPolicyArns:
        !If
          - CreateDebugResources
          - 
            - arn:aws:iam::aws:policy/service-role/AmazonSSMMaintenanceWindowRole
            - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
            - arn:aws:iam::aws:policy/service-role/AmazonEC2RoleforSSM
            - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
            - !Sub "arn:aws:iam::${AWS::AccountId}:policy/${AWS::StackName}-ASGSelfAccessPolicy"
            - !Sub "arn:aws:iam::${AWS::AccountId}:policy/${AWS::StackName}-EC2SelfAccessPolicy"
            - !Sub "arn:aws:iam::${AWS::AccountId}:policy/${AWS::StackName}-SSMParameterStorePolicy"
            - !Sub "arn:aws:iam::${AWS::AccountId}:policy/${AWS::StackName}-ASGBucketPolicy"                
          - 
            - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
            - !Sub "arn:aws:iam::${AWS::AccountId}:policy/${AWS::StackName}-ASGSelfAccessPolicy"
            - !Sub "arn:aws:iam::${AWS::AccountId}:policy/${AWS::StackName}-EC2SelfAccessPolicy"
            - !Sub "arn:aws:iam::${AWS::AccountId}:policy/${AWS::StackName}-SSMParameterStorePolicy"
            - !Sub "arn:aws:iam::${AWS::AccountId}:policy/${AWS::StackName}-ASGBucketPolicy"            

  SSMSyntheticCPULoad:
    Type: AWS::SSM::Parameter
    Condition: SetupSythenticCPULoad    
    Properties:
      Name: !Sub "${AWS::StackName}-SyntheticCPULoad"
      Type: String 
      Value: !Ref 8DBGCPULoadPercentInitialValue
      Description: Named as stackname-SyntheticCPULoad, contains CPU Load Percent Value.

  ASGBucket:
    Type: AWS::S3::Bucket
    Condition: CreateS3BucketAndPermissions    
    Properties:    
      BucketName: !Sub "${AWS::StackName}-asgbucket"
      VersioningConfiguration:
        Status: Enabled
        
  InstanceASG:
    Type: AWS::AutoScaling::AutoScalingGroup
    CreationPolicy:
      AutoScalingCreationPolicy:
        MinSuccessfulInstancesPercent: 75
      ResourceSignal:   
        Timeout: !If [InstancePlatformLinux,PT15M,PT1H] 
        Count: !Ref 4ASGDesiredCapacity          
        # !If
        #   - InstancePlatformLinux
        #   - 
        #     Timeout: PT15M
        #     Count: !Ref 4ASGDesiredCapacity
        #   - 
        #     Timeout: PT1H
        #     Count: !Ref 4ASGDesiredCapacity
    # Decide which UpdatePolicy to uncomment to see this template work with either one.
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MaxBatchSize: 2
        MinInstancesInService: 1
        MinSuccessfulInstancesPercent: 75
        WaitOnResourceSignals: true
        PauseTime: PT0M30S
        SuspendProcesses:
          - HealthCheck
          - ReplaceUnhealthy
          - AZRebalance
          - AlarmNotification
          - ScheduledActions
      AutoScalingReplacingUpdate:
        # WillReplace=true will make ReplacingUpdate take precedent over RollingUpdate
        !If
          - ReplaceEntireASG
          - WillReplace: true
          - WillReplace: false
    Properties:
      HealthCheckGracePeriod: 3
      AvailabilityZones:
        Fn::GetAZs:
          Ref: AWS::Region
      MinSize: '1'
      MaxSize: !Ref 5ASGAutoScalingMaxSize
      DesiredCapacity: !Ref 4ASGDesiredCapacity
      #Demonstrates an 1) **Optional dependency** on an ELB which can be sourced from either
      # 2) **A parent stack**, or 3) **overridden by a parameter** in this stack
      MixedInstancesPolicy:
        LaunchTemplate:
          LaunchTemplateSpecification:
            LaunchTemplateId:
              Ref: ASGLaunchTemplate
            Version: !GetAtt ASGLaunchTemplate.LatestVersionNumber 
          Overrides: 
            - !If 
              - Provided5SPOTInstanceType1
              - InstanceType: !Ref 5SPOTInstanceType1
              - !Ref "AWS::NoValue"
            - !If 
              - Provided5SPOTInstanceType2
              - InstanceType: !Ref 5SPOTInstanceType2
              - !Ref "AWS::NoValue"
            - !If 
              - Provided5SPOTInstanceType3
              - InstanceType: !Ref 5SPOTInstanceType3
              - !Ref "AWS::NoValue"
            - !If 
              - Provided5SPOTInstanceType4
              - InstanceType: !Ref 5SPOTInstanceType4
              - !Ref "AWS::NoValue"
        InstancesDistribution:
          SpotAllocationStrategy: !Ref 5SPOTSpotAllocationStrategy
          OnDemandAllocationStrategy: prioritized
          OnDemandBaseCapacity: !Ref 5SPOTOnDemandBaseCapacity
          OnDemandPercentageAboveBaseCapacity: !Ref 5SPOTOnDemandPercentageAboveBaseCapacity
      LifecycleHookSpecificationList:
      - LifecycleTransition: 'autoscaling:EC2_INSTANCE_LAUNCHING'
        LifecycleHookName: instance-patching-reboot
        HeartbeatTimeout: 3600
      - !If 
        - EnableSelfTerminationMonitoring
        - 
          LifecycleTransition: 'autoscaling:EC2_INSTANCE_TERMINATING'
          LifecycleHookName: instance-terminating
          HeartbeatTimeout: 3600
        - !Ref "AWS::NoValue"        

      Tags:
      - Key: Name
        Value: !Ref AWS::StackName
        PropagateAtLaunch: true
      - Key: LAST_CF_PATCH_RUN
        Value: !Ref 1OSPatchRunDate
        PropagateAtLaunch: true
  
  ScheduledActionDailyStart: 
    Condition: CreateStartSchedule
    Type: AWS::AutoScaling::ScheduledAction
    Properties:
      AutoScalingGroupName: 
        Ref: InstanceASG
      DesiredCapacity: !Ref 4ASGScheduledStartupDesiredInstances
      MinSize: 1
      Recurrence: !Ref 4ASGScheduledStartupCron
  
  ScheduledActionDailyStop: 
    Condition: CreateStopSchedule
    Type: AWS::AutoScaling::ScheduledAction
    Properties:
      AutoScalingGroupName: 
        Ref: InstanceASG
      DesiredCapacity: 0
      MinSize: 0
      Recurrence: !Ref 4ASGScheduledShutdownCron

  #Scaling policy and alarms are only created if autoscaling parameter is true
  ScaleDownPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Condition: ConfigureAutoscaling
    DependsOn: InstanceASG
    Properties:
      AutoScalingGroupName:
        Ref: InstanceASG
      #Replace the below section if a different type of scaling policy is desired
      PolicyType: StepScaling
      AdjustmentType: 'ChangeInCapacity'
      StepAdjustments:
        - MetricIntervalUpperBound: 0
          ScalingAdjustment: -1
      MetricAggregationType: 'Average'
      EstimatedInstanceWarmup: !If [InstancePlatformLinux,60,600]

  ScaleUpPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Condition: ConfigureAutoscaling    
    DependsOn: InstanceASG
    Properties:
      AutoScalingGroupName:
        Ref: InstanceASG
      PolicyType: StepScaling
      AdjustmentType: 'ChangeInCapacity'
      StepAdjustments:
        - MetricIntervalLowerBound: 0
          MetricIntervalUpperBound: 15
          ScalingAdjustment: 1
        - MetricIntervalLowerBound: 15
          MetricIntervalUpperBound: 25
          ScalingAdjustment: 2
        - MetricIntervalLowerBound: 25
          ScalingAdjustment: 3
      MetricAggregationType: 'Average'
      EstimatedInstanceWarmup: !If [InstancePlatformLinux,60,600]

  LowCpuUsageAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: ConfigureAutoscaling     
    DependsOn: InstanceASG
    Properties:
      AlarmDescription: "Low CPU alarm for: "
      MetricName: CPUUtilization
      Unit: Percent
      Namespace: AWS/EC2
      Dimensions:
        - Name: AutoScalingGroupName
          Value:
            Ref: InstanceASG
      Statistic: Average
      Period: !Ref 5ASGAutoScalingSetScaleInCPUThresholdSeconds
      EvaluationPeriods: 1
      Threshold: !Ref 5ASGAutoScalingSetScaleInCPUThreshold
      ComparisonOperator: LessThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleDownPolicy

  HighCpuUsageAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: ConfigureAutoscaling     
    DependsOn: InstanceASG
    Properties:
      AlarmDescription: "High CPU alarm for: "
      MetricName: CPUUtilization
      Unit: Percent      
      Namespace: AWS/EC2
      Dimensions:
        - Name: AutoScalingGroupName
          Value:
            Ref: InstanceASG
      Statistic: Average
      Period: !Ref 5ASGAutoScalingSetScaleOutCPUThresholdSeconds
      EvaluationPeriods: 1
      Threshold: !Ref 5ASGAutoScalingSetScaleOutCPUThreshold
      ComparisonOperator: GreaterThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleUpPolicy

  ASGLaunchTemplate:
    Type: "AWS::EC2::LaunchTemplate"
    Properties:
      LaunchTemplateData:
        ImageId:
          !If
            - UseLatestAMI
            - 
                Ref: 9AWSRetrieveLatestAWSOSAmiIdFromSSM
            - 
                Ref: 1OSPeggedAMIID
        #InstanceType is overridden by spot parameters
        InstanceType: t2.micro
        KeyName: !If [UseKeypair,!Ref 8DBGKeypairName,!Ref "AWS::NoValue"]
        IamInstanceProfile:
          !If
            - BuildInstanceRoleToUse
            -   Arn: !GetAtt ASGInstanceProfile.Arn
            -   Arn: !Sub "arn:aws:iam::${AWS::AccountId}:instance-profile/${9AWSSpecifiedIAMRoleNAME}"
        BlockDeviceMappings:
        - DeviceName: "/dev/xvda"
          Ebs:
            VolumeType: 'gp2'
            VolumeSize: 30
        UserData:      
          !If
            - InstancePlatformLinux
            - 
              # **************
              # Linux UserData
              Fn::Base64: !Sub | 
                #!/bin/bash
                set -xv
                AWSASGLabKitVersion="${1AAAAUltimateASGVersion}"
                function logit() {
                  LOGSTRING="$(date +"%_b %e %H:%M:%S") $(hostname) USERDATA_SCRIPT: $1"
                  echo "$LOGSTRING"
                  #For CloudFormation, if you already collect /var/log/cloud-init-output.log or /var/log/messsages (non amazon linux), then you could mute the next logging line
                  echo "$LOGSTRING" >> /var/log/messages
                }                     
                logit "Building Linux Instance... with AWS ASG Lab Kit Version: $AWSASGLabKitVersion"
                logit "Learn more at: $1AAAReadmeBlogPost"
                logit "Logs for this are found in /var/log/cloud-init-output.log or /var/log/messsages (non amazon linux)"
                logit "Rendered script found in /var/lib/cloud/instance/scripts/part-001"   
                yum install -y jq unzip yum-utils amazon-linux-extras amazon-cloudwatch-agent

                if [[ "${8DBGTroubleShootingMode}" == "true" ]]; then
                  if ! ps -ef | grep -q '[a]mazon-ssm-agent'; then
                    logit "8DBGTroubleShootingMode is true - and SSM is not installed, Installing SSM for Session Manager Access..."
                    sudo yum install -y https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_amd64/amazon-ssm-agent.rpm
                    sudo start amazon-ssm-agent
                  fi
                fi
                if [[ -z "$(command -v aws)" ]] ; then
                  logit "AWS CLI is not present, installing it to control asg lifecycle hook completion..."
                  if [[ -z "$(command -v pip)" ]] ; then
                    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                    unzip -q awscliv2.zip
                    ./aws/install -i /usr/local/aws-cli -b /usr/bin
                    rm -rf aws
                  fi
                  pip install awscli --upgrade
                fi     
                if [[ ! -f /opt/aws/bin/cfn-signal ]] ; then
                  logit "cfn-bootstrap is not present, installing it to control cloud formation completion..."
                  yum install -y epel-release
                  yum install -y https://s3.amazonaws.com/cloudformation-examples/aws-cfn-bootstrap-latest.amzn1.noarch.rpm
                  sudo ln -s /usr/local/lib/python2.7/site-packages/cfnbootstrap /usr/lib/python2.7/site-packages/cfnbootstrap
                fi      
                
                GITLABRunnerInstanceURL="${3GITLABRunnerInstanceURL}"
                GITLABRunnerRegTokenList="${3GITLABRunnerRegTokenList}"
                GITLABRunnerVersion="${3GITLABRunnerVersion}"
                GITLABRunnerTagList="${3GITLABRunnerTagList}"
                GITLABRunnerExecutor="${3GITLABRunnerExecutor}"
                INSTANCEOSPLATFORM="${1OSInstanceOSPlatform}"
                RunnerOSTags="$(echo $INSTANCEOSPLATFORM | awk '{print tolower($0)}' )"
                #RunnerConfigTomlTemplate #(Embedded, local or s3:// or http*://)
                #RunnerInstallRoot='/usr/local/bin'
                RunnerInstallRoot='/gitlab-runner'
                RunnerConfigToml="/etc/gitlab-runner/config.toml"
                ASGSelfMonitorTerminationInterval="${5ASGSelfMonitorTerminationInterval}"
                
                if [[ "${4ASGScheduledStartupCron}" != "Disabled" ]] || [[ "${4ASGScheduledShutdownCron}" != "Disabled" ]]; then GITLABRunnerTagList = "$GITLABRunnerTagList, UsesAWSASGScheduledAvailability"; fi

                AWS_REGION="$(curl -s 169.254.169.254/latest/meta-data/placement/availability-zone | sed 's/.$//')"
                GITLABRunnerTagList = "$GITLABRunnerTagList, AWSRegion-$AWS_REGION"                

                LAST_CF_PATCH_RUN="${1OSPatchRunDate}" #Forces change for patching rolling replacement and documents last CF triggered patching
                ACTUAL_PATCH_DATE=$(date +%Y-%m-%d)
                MYINSTANCEID="$(curl http://169.254.169.254/latest/meta-data/instance-id)"
 
                NAMEOFASG=$(aws ec2 describe-tags --region $AWS_REGION --filters {"Name=resource-id,Values=$MYINSTANCEID","Name=key,Values=aws:autoscaling:groupName"} --output=text | cut -f5)
                NAMEOFSTACK=${AWS::StackName}
                PATCHDONEFLAG=/root/patchingrebootwasdone.flg
                logit "Processing userdata script on instance: $MYINSTANCEID"
                logit "Operating in Region: $AWS_REGION, launched from ASG: $NAMEOFASG"
                yum update yum-utils yum-plugin-security
                uname -r
                COMPUTETYPE="PROBLEM FINDING SPOT STATUS"
                if [[ "$(aws ec2 describe-instances --filters Name=instance-id,Values="$MYINSTANCEID" --region $AWS_REGION | jq -r '.Reservations[].Instances[].SpotInstanceRequestId')" != "null" ]]; then
                  COMPUTETYPE="SPOT"
                else
                  COMPUTETYPE="ONDEMAND"
                fi
                aws ec2 create-tags --resources $MYINSTANCEID --tags Key=COMPUTETYPE,Value=$COMPUTETYPE --region $AWS_REGION
                if [ ! -z $NAMEOFASG ]; then
                  logit "Instance is in an ASG, will process lifecycle hooks"
                  logit "Listing hook to verify permissions and hook presence"
                  aws autoscaling describe-lifecycle-hooks --region $AWS_REGION --auto-scaling-group-name $NAMEOFASG
                else
                  logit "Instance is not in an ASG or if it is, the instance profile used does not have permissions to its own tags."
                fi

                if [ -f $PATCHDONEFLAG ]; then
                  logit "Completed a post-patching reboot, skipping patching check..."
                else
                  logit "Lets patch - including the kernel if necessary..."
                  if [[ "${1OSPatchScope}" == "All" ]]; then
                    logit "Started Patching."
                    yum update -y
                    logit "Completed Patching."
                  elif [[ "${1OSPatchScope}" == "SecurityOnly" ]]; then
                    logit "Started Patching."
                    yum --security update -y
                    logit "Completed Patching."
                  elif [[ "${1OSPatchScope}" == "NoPatching-OnlyForDebugging" ]]; then
                    logit "No patching will be done - this setting is for debugging only (patch dates will still be set)"
                  fi
                  logit "ACTUAL_PATCH_DATE may be newer because this instance was autoscaled after the LAST_CF_PATCH_RUN"
                  logit "LAST_CF_PATCH_RUN: $LAST_CF_PATCH_RUN"
                  echo "export LAST_CF_PATCH_RUN=$LAST_CF_PATCH_RUN" >> /etc/profile.d/lastpatchingdata.sh
                  logit "ACTUAL_PATCH_DATE: $ACTUAL_PATCH_DATE"
                  echo "export ACTUAL_PATCH_DATE=$ACTUAL_PATCH_DATE" >> /etc/profile.d/lastpatchingdata.sh
                fi
                
                logit "Continuing..."
                if [ ! -z $NAMEOFASG ]; then
                  logit "Sending a heart beat to reset the timeout counter while doing more things (just as an example)..."
                  aws autoscaling record-lifecycle-action-heartbeat --region $AWS_REGION --instance-id $MYINSTANCEID --lifecycle-hook-name instance-patching-reboot --auto-scaling-group-name $NAMEOFASG
                fi

                #Check if already installed or running
                if [[ "${3INSTInstallCodeDeploy}" == "true" ]]; then
                  logit "Code Deploy Install..."
                  yum install -y ruby
                  cd /tmp
                  aws s3 cp s3://aws-codedeploy-us-east-1/latest/install . --region $AWS_REGION
                  chmod +x ./install
                  ./install auto
                fi

                #This approach for termination hook is much simpler than those involving SNS or CloudWatch, but when deployed 
                # on many instances it can result in a lot of ASG Describe API calls (which may be rate limited).
                ASGSelfMonitorTerminationInterval=${5ASGSelfMonitorTerminationInterval}
                if [ ! -z "$NAMEOFASG" ] && [ "$ASGSelfMonitorTerminationInterval" != "Disabled" ] && [ "$WaitingForReboot" != "true" ]; then
                  logit "Setting up termination monitoring because 5ASGSelfMonitorTerminationInterval is set to $ASGSelfMonitorTerminationInterval"
                  SCRIPTNAME=/etc/cron.d/MonitorTerminationHook.sh
                  SCRIPTFOLDER=$(dirname $SCRIPTNAME)
                  SCRIPTBASENAME=$(basename $SCRIPTNAME)
                  
                  #Heredoc script
                  cat << EndOfScript > $SCRIPTNAME
                    function logit() {
                      LOGSTRING="\$(date +"%_b %e %H:%M:%S") \$(hostname) TERMINATIONMON_SCRIPT: \$1"
                      echo "\$LOGSTRING"
                      echo "\$LOGSTRING" >> /var/log/messages
                    }
                    #These are resolved at script creation time to reduce api calls when this script runs every minute on instances.
               
                    if [[ "\$(aws autoscaling describe-auto-scaling-instances --instance-ids $MYINSTANCEID --region $AWS_REGION | jq --raw-output '.AutoScalingInstances[0] .LifecycleState')" == *"Terminating"* ]]; then
                      logit "This instance ($MYINSTANCEID) is being terminated, perform cleanup..."

                      #### PUT YOUR CLEANUP CODE HERE, DECIDE IF CLEANUP CODE SHOULD ERROR OUT OR SILENTLY FAIL (best effort cleanup)

                      aws autoscaling complete-lifecycle-action --region $AWS_REGION --lifecycle-action-result CONTINUE --instance-id $MYINSTANCEID --lifecycle-hook-name instance-terminating --auto-scaling-group-name $NAMEOFASG
                      logit "This instance ($MYINSTANCEID) is ready for termination"
                      logit "Lifecycle CONTINUE was sent to termination hook in ASG: $NAMEOFASG for this instance ($MYINSTANCEID)."
                    fi

                EndOfScript

                  logit "SCHEDULING: $SCRIPTNAME for every $ASGSelfMonitorTerminationInterval minutes to check for termination hook."

                  chown root:root "$SCRIPTNAME"
                  chmod 644 "$SCRIPTNAME"
                  logit "Adding cron job"
                  echo "$ASGSelfMonitorTerminationInterval * * * * root bash $SCRIPTNAME" | tee -a /etc/crontab > /dev/null
                  logit "adding to /etc/crontab: */$ASGSelfMonitorTerminationInterval * * * * root bash $SCRIPTNAME"
                  chown root:root /etc/crontab
                  chmod 644 /etc/crontab
                fi

                DefaultLocalCachedConfigScript="custom_instance_configuration_script.sh"
                logit "##########################################"
                logit "RUNNING CUSTOM INSTANCE CONFIGURATION CODE"

                #If indicated as embedded, run it.
                if [[ "${3INSTConfigurationScript}" == "Embedded" ]]; then
                  logit "CUSTOM CONFIG: Running embedded custom instance configuration script."
                  #############################################
                  # YOUR CODE HERE
                  #############################################

                elif [[ "${3INSTConfigurationScript}" == "http://"* || "${3INSTConfigurationScript}" == "https://"* ]]; then
                  logit "CUSTOM CONFIG: Retrieving custom instance configuration script from ${3INSTConfigurationScript}"
                  if [ ! -f $DefaultLocalCachedConfigScript ]; then
                      logit "Pulling and executing from \"${3INSTConfigurationScript}\""
                      if [ -n "$(command -v curl)" ]; then
                          logit "found and using curl"
                          curl -o $DefaultLocalCachedConfigScript -s ${3INSTConfigurationScript}
                      elif [ -n "$(command -v wget)" ]; then
                          logit "found and using wget"
                          wget -O $DefaultLocalCachedConfigScript -s ${3INSTConfigurationScript}
                      else
                          logit "Could not find curl or wget, install one of these or manually copy \"${3INSTConfigurationScript}\""
                      fi
                  fi

                elif [[ "${3INSTConfigurationScript}" == "s3://"* ]]; then
                  logit "CUSTOM CONFIG: Retrieving custom instance configuration script from ${3INSTConfigurationScript}"
                  if [ ! -f $DefaultLocalCachedConfigScript ]; then
                      logit "Pulling and executing from \"${3INSTConfigurationScript}\""
                      aws s3 cp ${3INSTConfigurationScript} $DefaultLocalCachedConfigScript
                  fi
                else
                  logit "CUSTOM CONFIG: Running custom instance configuration script in the local file named ${3INSTConfigurationScript}"
                  if [ -f $DefaultLocalCachedConfigScript ]; then
                    logit "Pointing \$DefaultLocalCachedConfigScript to ${3INSTConfigurationScript}"
                    DefaultLocalCachedConfigScript=${3INSTConfigurationScript}
                  else
                    logit "${3INSTConfigurationScript} was not found, will error out."
                  fi
                fi

                if [ "${3INSTConfigurationScript}" != "Embedded" ]; then
                  logit "Execution of the Non-Embedded Instance Configuration Script \"$DefaultLocalCachedConfigScript\" has been requested."
                  if [ -f "$DefaultLocalCachedConfigScript" ]; then
                    source "$DefaultLocalCachedConfigScript"
                  else
                    logit "ERROR: $DefaultLocalCachedConfigScript was not found, but is needed to complete instance setup."
                    exit 9
                  fi
                fi

                # END OF "RUNNING CUSTOM INSTANCE CONFIGURATION CODE"
                # ###################################################

                needs-restarting -r 
                if [ $? -gt 0 ]; then
                  logit "Detected that a reboot is required, rebooting..."
                  logit "Resetting userdata semaphore..."
                  rm /var/lib/cloud/instances/*/sem/config_scripts_user
                  touch $PATCHDONEFLAG
                  reboot
                  logit "Waiting for reboot to complete..."
                  sleep 30
                  WaitingForReboot=true
                fi

                if [ ! -z "$NAMEOFASG" ] && [ "$WaitingForReboot" != "true" ]; then
                  logit "Completing lifecycle action hook so that ASG knows we are ready to be placed InService..."
                  aws autoscaling complete-lifecycle-action --region $AWS_REGION --lifecycle-action-result CONTINUE --instance-id $MYINSTANCEID --lifecycle-hook-name instance-patching-reboot --auto-scaling-group-name $NAMEOFASG
                fi
                
                if [ "$WaitingForReboot" != "true" ]; then
                  logit "Cfn-signaling success..."
                  /opt/aws/bin/cfn-signal --success true --stack ${AWS::StackName} --resource InstanceASG --region $AWS_REGION
                fi

                DBGCPULoadPercentInitialValue=${8DBGCPULoadPercentInitialValue}
                if [ "$WaitingForReboot" != "true" ] && [ -n "$DBGCPULoadPercentInitialValue" ]; then
                  logit "Setting up CPU stressing because 8DBGCPULoadPercentInitialValue was set to $DBGCPULoadPercentInitialValue"
                  if [[ ! -z "$(command -v amazon-linux-extras)" ]] ; then
                    amazon-linux-extras install epel -y
                  fi
                  yum install -y curl stress-ng
                  CPUPercent="$(aws --region=$AWS_REGION ssm get-parameter --name "$NAMEOFSTACK-SyntheticCPULoad" --output text --query Parameter.Value | grep -E ^\-?[0-9]+$)"
                  while [ "$CPUPercent" != '' ]; do
                    logit "Stressing for 1 minute at $CPUPercent percent CPU utilization before checking for updated percentage."
                    stress-ng -c 0 -l $CPUPercent --timeout 60
                    CPUPercent="$(aws --region=$AWS_REGION ssm get-parameter --name "$NAMEOFSTACK-SyntheticCPULoad" --output text --query Parameter.Value | grep -E ^\-?[0-9]+$)"
                  done
                  logit "Stopping CPU stressing due to receving non-numeric value: \"$(aws --region=$AWS_REGION ssm get-parameter --name "$NAMEOFSTACK-SyntheticCPULoad" --output text --query Parameter.Value)\""
                fi              
            - 
              # **************
              # Windows UserData
              Fn::Base64: !Sub | 
                <powershell>
                $AWSASGLabKitVersion="${1AAAAUltimateASGVersion}"
                Function lc-success {aws autoscaling complete-lifecycle-action --region $AWS_REGION --lifecycle-action-result CONTINUE --instance-id $MYINSTANCEID --lifecycle-hook-name instance-patching-reboot --auto-scaling-group-name $NAMEOFASG}
                Function cf-success {cfn-signal --success true --stack ${AWS::StackName} --resource InstanceASG --region $AWS_REGION}
                Trap { if ($8DBGTroubleShootingMode -eq 'true') { lc-success; cf-success}}
                Function logit ($Msg, $MsgType='Information', $ID='1') {
                  If ($script:PSCommandPath -ne '' ) { $SourcePathName = $script:PSCommandPath ; $SourceName = split-path -leaf $SourcePathName } else { $SourceName = "Automation Code"; $SourcePathName = "Unknown" }
                  Write-Host "[$(Get-date -format 'yyyy-MM-dd HH:mm:ss zzz')] $MsgType : From: $SourcePathName : $Msg"
                  $applog = New-Object -TypeName System.Diagnostics.EventLog -argumentlist Application
                  $applog.Source="$SourceName"
                  $applog.WriteEntry("From: $SourcePathName : $Msg", $MsgType, $ID)
                }                
                logit "Building Instance... with AWS ASG Lab Kit Version: $AWSASGLabKitVersion"
                logit "Learn more at: $1AAAReadmeBlogPost"
                logit "On 2012 R2 and earlier (Ec2Config) errors are logged to cat C:\Program Files\Amazon\Ec2ConfigService\Logs\Ec2ConfigLog.txt"
                logit "On 2016 and later (Ec2Launch) errors are logged to cat C:\programdata\Amazon\EC2-Windows\Launch\Log\UserdataExecution.log" 
                logit "Rendered script on an instance will be found at: C:\Windows\TEMP\UserScript.ps1"               

                If ((![bool](get-process amazon-ssm-agent -ErrorAction SilentlyContinue)) -AND ($8DBGTroubleShootingMode -eq 'true')) {
                  logit "8DBGTroubleShootingMode is true and SSM is not present - Installing SSM for Session Manager Access..."
                  Invoke-WebRequest https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/windows_amd64/AmazonSSMAgentSetup.exe -OutFile $env:USERPROFILE\SSMAgent_latest.exe
                  Start-Process	-FilePath $env:USERPROFILE\SSMAgent_latest.exe -ArgumentList "/S"
                }              
                If (!(Test-Path "C:\Program Files\Amazon\AWSCLI\bin\aws.exe")) {
                  logit "Installing AWS CLI to control lifecycle hook updates..."
                  $AWSCLIURL="https://s3.amazonaws.com/aws-cli/AWSCLI64PY3.msi" #v1
                  #$AWSCLIURL="https://awscli.amazonaws.com/AWSCLIV2.msi" #v2
                  Invoke-WebRequest $AWSCLIURL -OutFile $env:USERPROFILE\AWSCLI.msi
                  Start-Process	 -wait -nonewwindow -FilePath "msiexec.exe" -ArgumentList "/i $env:USERPROFILE\AWSCLI.msi /l*v $env:USERPROFILE\\AWSCLI-install.log /qn"
                  $env:PATH="$env:PATH;C:\Program Files\Amazon\AWSCLI\bin"
                  #$env:PATH="$env:PATH;C:\Program Files\Amazon\AWSCLIV2"
                  If (![bool](get-command aws.exe)) {
                    throw "AWS CLI did not install correctly"
                  }
                }
                If (![bool](get-command cfn-signal.exe)) {
                  logit "cfn-bootstrap is not present, installing it to control cloud formation completion..."
                  Invoke-WebRequest https://s3.amazonaws.com/cloudformation-examples/aws-cfn-bootstrap-win64-latest.msi -OutFile $env:USERPROFILE\aws-cfn-bootstrap-win64-latest.msi
                  Start-Process	 -wait -nonewwindow -FilePath "msiexec.exe" -ArgumentList "/i $env:USERPROFILE\aws-cfn-bootstrap-win64-latest.msi /l*v $env:USERPROFILE\aws-cfn-bootstrap-win64-latest.log /qn"
                }
                Function Test-PendingReboot
                {
                  Return ([bool]((get-itemproperty "hklm:SYSTEM\CurrentControlSet\Control\Session Manager").RebootPending) -OR 
                  [bool]((get-itemproperty "HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update").RebootRequired) -OR 
                  [bool]((get-itemproperty "HKLM:SYSTEM\CurrentControlSet\Control\Session Manager").PendingFileRenameOperations) -OR 
                  ((test-path c:\windows\winsxs\pending.xml) -AND ([bool](get-content c:\windows\winsxs\pending.xml | Select-String 'postAction="reboot"'))) -OR 
                  ((get-itemproperty 'HKLM:SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\' | Select-Object -Expand 'ComputerName') -ine (get-itemproperty 'HKLM:SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName\' | Select-Object -Expand 'ComputerName')) -OR 
                  ((Test-Path "HKLM:SYSTEM\CurrentControlSet\Services\Netlogon\JoinDomain") -OR (Test-Path "HKLM:SYSTEM\CurrentControlSet\Services\Netlogon\AvoidSpnSet")))
                }

                $GITLABRunnerInstanceURL="${3GITLABRunnerInstanceURL}"
                $GITLABRunnerRegTokenList="${3GITLABRunnerRegTokenList}"
                $GITLABRunnerVersion="${3GITLABRunnerVersion}"
                $GITLABRunnerTagList="${3GITLABRunnerTagList}"
                $GITLABRunnerExecutor="${3GITLABRunnerExecutor}"
                $INSTANCEOSPLATFORM="${1OSInstanceOSPlatform}"
                $RunnerOSTags="$($INSTANCEOSPLATFORM.ToLower())"
                $RunnerConfigTomlTemplate #(Embedded, local or s3:// or http*://)
                $RunnerInstallRoot='C:\GitLab-Runner'
                $RunnerConfigToml="$RunnerInstallRoot\config.toml"
                
                If (("${4ASGScheduledStartupCron}" -ine "Disabled") -OR ("${4ASGScheduledShutdownCron}" -ine "Disabled")) { $GITLABRunnerTagList = "$GITLABRunnerTagList, UsesAWSASGScheduledAvailability"}

                $AWS_REGION="$($(invoke-restmethod 169.254.169.254/latest/meta-data/placement/availability-zone) -replace '.$')"
                $GITLABRunnerTagList = "$GITLABRunnerTagList, AWSRegion-$AWS_REGION"

                $LAST_CF_PATCH_RUN="${1OSPatchRunDate}" #Forces change for patching rolling replacement and documents last CF triggered patching
                $ACTUAL_PATCH_DATE="$(date -format 'yyyy-MM-dd')"
                $MYINSTANCEID="$(invoke-restmethod http://169.254.169.254/latest/meta-data/instance-id)"
                $NAMEOFASG=$(aws ec2 describe-tags --region $AWS_REGION --filters Name=resource-id,Values=$MYINSTANCEID Name=key,Values=aws:autoscaling:groupName | convertfrom-json).tags.value
                $NAMEOFSTACK="${AWS::StackName}"
                $PATCHDONEFLAG="$env:USERPROFILE/patchingrebootwasdone.flg"
                $1OSPatchScopeToUse="${1OSPatchScope}"
                logit "Processing userdata script on instance: $MYINSTANCEID"
                logit "Operating in Region: $AWS_REGION, launched from ASG: $NAMEOFASG"
                $COMPUTETYPE="PROBLEM FINDING SPOT STATUS"
                if ( "$((aws ec2 describe-instances --region $AWS_REGION --instance-id $MYINSTANCEID | convertfrom-json).Reservations.Instances.SpotInstanceRequestId)" -ne "" ) {
                  $COMPUTETYPE='SPOT'
                } else {
                  $COMPUTETYPE='ONDEMAND'
                }
                aws ec2 create-tags --region $AWS_REGION --resources $MYINSTANCEID --tags "Key=`"COMPUTETYPE`",Value=$COMPUTETYPE"
                if ($NAMEOFASG) {
                  logit "Instance is in an ASG, will process lifecycle hooks"
                  logit "Listing hook to verify permissions and hook presence"
                  aws --region $AWS_REGION autoscaling describe-lifecycle-hooks --auto-scaling-group-name $NAMEOFASG
                } else {
                  logit "Instance is not in an ASG or if it is, the instance profile used does not have permissions to its own tags."
                }

                if (Test-Path $PATCHDONEFLAG) {
                  logit "Completed a post-patching reboot, skipping patching check..."
                } else {
                  logit "Lets patch (including the kernel if necessary)..."
                  logit "IMPORTANT: Windows update only updates installed os components.  If you install a component like IIS after this, you will need to run the patching commands again."

                  if ((get-module -listavailable PSWindowsUpdate).count -lt 1) {
                    Write-Host "PSWindowsUpdate is not available, installing..."
                    install-module pswindowsupdate -SkipPublisherCheck -Force
                  }

                  Switch ($1OSPatchScopeToUse) {
                    "SecurityOnly" { logit "Starting Patching."; Install-WindowsUpdate -MicrosoftUpdate -Category "Security Updates" -AcceptAll -Verbose; logit "Completed Patching." }
                    "All" { logit "Starting Patching."; Install-WindowsUpdate -MicrosoftUpdate -AcceptAll -Verbose; logit "Completed Patching." }
                    "NoPatching-OnlyForDebugging" {logit -MsgType 'Warning' -ID 4 -Msg "No patching will be done - this setting is for debugging only (patch dates will still be set)" }
                  }

                  $LatestNGENBinary = $(Get-ChildItem $env:windir\microsoft.net\framework64\v*\ngen.exe | sort-object | select-object -last 1 | select-object -expand FullName)

                  If ($LatestNGENBinary) {
                    logit "Running Native Assembly Generation to process .NET updates immediately. Most errors can be ignored."
                    Start-Process $LatestNGENBinary -ArgumentList 'update' -nonewwindow -wait
                    logit "Native Assembly Generation Complete. Most errors can be ignored."
                  } else {
                    logit -MsgType 'Warning' -ID 7 "Warning ngen.exe was not found, which means .NET may not be installed - a highly unusual situation."
                  }
                  
                  logit "ACTUAL_PATCH_DATE may be newer because this instance was autoscaled after the LAST_CF_PATCH_RUN"
                  logit "LAST_CF_PATCH_RUN: $LAST_CF_PATCH_RUN"
                  set-content $env:public/lastpatchingdata.ps1 "$LAST_CF_PATCH_RUN=$LAST_CF_PATCH_RUN"
                  logit "ACTUAL_PATCH_DATE: $ACTUAL_PATCH_DATE"
                  add-content $env:public/lastpatchingdata.ps1 "$ACTUAL_PATCH_DATE=$ACTUAL_PATCH_DATE"
                }

                if (("${3INSTInstallCodeDeploy}" -eq "true") -AND (![bool](get-service codedeployagent -ErrorAction SilentlyContinue))) {
                  logit "Code deploy is requested, but not present, installing CodeDeploy"
                  aws s3 cp s3://aws-codedeploy-$AWS_REGION/latest/codedeploy-agent.msi $env:USERPROFILE\codedeploy-agent.msi  --region $AWS_REGION
                  Start-Process	 -wait -nonewwindow -FilePath "msiexec.exe" -ArgumentList "/i $env:USERPROFILE\codedeploy-agent.msi /l*v $env:USERPROFILE\codedeploy-agent.log /qn"
                }

                #This approach for termination hook is much simpler than those involving SNS or CloudWatch, but when deployed 
                # on many instances it can result in a lot of ASG Describe API calls (which may be rate limited).
                # variables identifying the instance and asg are hard coded into the script to reduce api calls.
                $ASGSelfMonitorTerminationInterval=${5ASGSelfMonitorTerminationInterval}
                if ($NAMEOFASG -AND ($ASGSelfMonitorTerminationInterval -ne "Disabled") -AND (!$WaitingForReboot -eq $True)) {
                  logit "Setting up termination monitoring because 5ASGSelfMonitorTerminationInterval is set to $ASGSelfMonitorTerminationInterval"
                  $SCRIPTNAME="$env:public\MonitorTerminationHook.ps1"
                  
                  #Heredoc script
                  set-content $SCRIPTNAME -Value @"
                    Function logit (`$Msg, `$MsgType='Information', `$ID='1') {
                      If (`$script:PSCommandPath -ne '' ) { `$SourcePathName = `$script:PSCommandPath ; `$SourceName = split-path -leaf `$SourcePathName } else { `$SourceName = "Automation Code"; `$SourcePathName = "Unknown" }
                      Write-Host "[`$(Get-date -format 'yyyy-MM-dd HH:mm:ss zzz')] `$MsgType : From: `$SourcePathName : `$Msg"
                      `$applog = New-Object -TypeName System.Diagnostics.EventLog -argumentlist Application
                      `$applog.Source="`$SourceName"
                      `$applog.WriteEntry("From: `$SourcePathName : `$Msg", `$MsgType, `$ID)
                    }
                
                    if ( (aws autoscaling describe-auto-scaling-instances --instance-ids $MYINSTANCEID --region $AWS_REGION | convertfrom-json).AutoScalingInstances.LifecycleState -ilike "*Terminating*" ) {
                      logit "This instance ($MYINSTANCEID) is being terminated, perform cleanup..."

                      #### PUT YOUR CLEANUP CODE HERE, DECIDE IF CLEANUP CODE SHOULD ERROR OUT OR SILENTLY FAIL (best effort cleanup)

                      aws autoscaling complete-lifecycle-action --region $AWS_REGION --lifecycle-action-result CONTINUE --instance-id $MYINSTANCEID --lifecycle-hook-name instance-terminating --auto-scaling-group-name $NAMEOFASG
                      logit "This instance ($MYINSTANCEID) is ready for termination"
                      logit "Lifecycle CONTINUE was sent to termination hook in ASG: $NAMEOFASG for this instance ($MYINSTANCEID)."
                    }

                "@

                  logit "SCHEDULING: $SCRIPTNAME for every $ASGSelfMonitorTerminationInterval minutes to check for termination hook."
                  schtasks.exe /create /sc MINUTE /MO $ASGSelfMonitorTerminationInterval /tn "MonitorTerminationHook.ps1" /ru SYSTEM /tr "powershell.exe -file $SCRIPTNAME"

                }

                $DefaultLocalCachedConfigScript="$env:public\custom_instance_configuration_script.ps1"
                $INSTConfigurationScript="${3INSTConfigurationScript}"
                logit "####"
                logit "RUNNING CUSTOM INSTANCE CONFIGURATION CODE"

                #If indicated as embedded, run it.
                if ( $INSTConfigurationScript -eq "Embedded" ) {
                  logit "CUSTOM CONFIG: Running embedded custom instance configuration script."
                  ######
                  # YOUR INSTANCE CONFIG CODE HERE

                } elseif (($INSTConfigurationScript -ilike "http://*") -OR ($INSTConfigurationScript -ilike "https://*" )) {
                  logit "CUSTOM CONFIG: Retrieving custom instance configuration script from $INSTConfigurationScript"
                  if (!(Test-Path $DefaultLocalCachedConfigScript)) {
                      logit "Pulling and executing from `"$INSTConfigurationScript`""
                      [Net.ServicePointManager]::SecurityProtocol = "tls12, tls11, tls"
                      Invoke-RestMethod -OutFile $DefaultLocalCachedConfigScript -Uri $INSTConfigurationScript
                    }
                } elseif ( $INSTConfigurationScript -ilike "s3://*" ) {
                  logit "CUSTOM CONFIG: Retrieving custom instance configuration script from $INSTConfigurationScript"
                  if (!(Test-Path $DefaultLocalCachedConfigScript)) {
                      aws s3 cp $INSTConfigurationScript $DefaultLocalCachedConfigScript
                  } else {
                    logit "$DefaultLocalCachedConfigScript was not found, will error out."
                  }                  
                } else {
                  logit "CUSTOM CONFIG: Running custom instance configuration script in the local file named $INSTConfigurationScript"
                  if (!(Test-Path $DefaultLocalCachedConfigScript)) {
                    logit "Pointing \$DefaultLocalCachedConfigScript to $INSTConfigurationScript"
                    DefaultLocalCachedConfigScript=$INSTConfigurationScript
                  } else {
                    logit "$DefaultLocalCachedConfigScript was not found, will error out."
                  }
                }

                if ( $INSTConfigurationScript -ne "Embedded") {
                  logit "Execution of the Non-Embedded Instance Configuration Script `"$DefaultLocalCachedConfigScript`" has been requested."
                  if (Test-Path $DefaultLocalCachedConfigScript) {
                    . "$DefaultLocalCachedConfigScript"
                  } else {
                    throw "ERROR: $DefaultLocalCachedConfigScript was not found, but is needed to complete instance setup."
                    exit 9
                  }
                }
                # END OF CUSTOM INSTANCE CONFIGURATION CODE"

                If (Test-PendingReboot)
                  {
                    logit "Reboot pending, shutting down in 10 seconds (giving time for orchestrating automation to close out)..."
                    $WaitingForReboot=$True
                    logit "Ensuring userdata will be processed again"
                    $path = 'C:\Program Files\Amazon\Ec2ConfigService\Settings\config.xml'
                    if (Test-Path $path) {
                      logit "Reseting Ec2Config userdata"
                      $xml = [xml](Get-Content $path)
                      $state = $xml.Ec2ConfigurationSettings.Plugins.Plugin | where {$_.Name -eq 'Ec2HandleUserData'}
                      $state.State = 'Disabled'
                      $xml.Save($path)
                    }
                    $path = 'C:\ProgramData\Amazon\Ec2-Windows\Launch\Config\LaunchConfig.json'
                    if (Test-Path $path) {
                      $ec2launchconfig = get-content $path | convertfrom-json
                      if (!$($ec2launchconfig.handleUserData)) {
                        logit "Reseting Ec2Launch userdata"
                        $ec2launchconfig.handleUserData = $True
                        $ec2launchconfig | convertto-json | set-content $path
                      }
                    }
                    shutdown.exe /r /t 10
                  } Else {
                    Write-Host "A reboot is not pending, no action taken."
                  }


                if ($NAMEOFASG -AND !$WaitingForReboot) {
                  logit "Completing lifecycle action hook so that ASG knows we are ready to be placed InService..."
                  lc-success
                }
                
                if (!$WaitingForReboot) {
                  logit "Cfn-signaling success..."
                  cf-success
                }

                $DBGCPULoadPercentInitialValue=${8DBGCPULoadPercentInitialValue}
                if (($WaitingForReboot -ne $True ) -AND ($DBGCPULoadPercentInitialValue)) {
                  logit "Setting up CPU stressing because 8DBGCPULoadPercentInitialValue was set to $DBGCPULoadPercentInitialValue"
                  Invoke-WebRequest https://github.com/vikyd/go-cpu-load/releases/download/0.0.1/go-cpu-load-win-amd64.exe -UseBasicParsing -outfile go-cpu-load-win-amd64.exe
                  $CPUPercent="$(aws --region=$AWS_REGION ssm get-parameter --name $NAMEOFSTACK-SyntheticCPULoad --output text --query Parameter.Value)"
                  while ( $CPUPercent -match "^[\d\.]+$" ) {
                    logit "Stressing for 1 minutes at $CPUPercent percent CPU utilization."
                    . .\go-cpu-load-win-amd64.exe -p $CPUPercent -t 60
                    $CPUPercent="$(aws --region=$AWS_REGION ssm get-parameter --name $NAMEOFSTACK-SyntheticCPULoad --output text --query Parameter.Value)"
                  }
                  logit "Stopping CPU stressing due to receving non-numeric value: `"$CPUPercent`""
                }
                </powershell>              
